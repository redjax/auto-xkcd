{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"auto-xkcd","text":"<p>Warning</p> <p>\ud83d\udea7  WIP  \ud83d\udea7</p> <p>Automate downloading XKCD comics from the XKCD API</p>"},{"location":"#setup","title":"Setup","text":"<p>Todo</p> <ul> <li>[ ] Write setup instructions</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>Todo</p> <ul> <li>Write setup instructions<ul> <li>Development with <code>pdm</code></li> <li>Running with Docker</li> </ul> </li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>auto_xkcd<ul> <li>_setup</li> <li>core<ul> <li>config</li> <li>constants</li> <li>database<ul> <li>annotated<ul> <li>annotated_columns</li> </ul> </li> <li>base</li> <li>db_config</li> <li>methods</li> <li>mixins<ul> <li>classes</li> </ul> </li> </ul> </li> <li>dependencies</li> <li>exc<ul> <li>custom</li> </ul> </li> <li>paths</li> <li>request_client<ul> <li>context_managers<ul> <li>_client</li> </ul> </li> <li>encoders<ul> <li>json_encoders<ul> <li>_encoders</li> </ul> </li> </ul> </li> <li>methods</li> <li>transports<ul> <li>_transports</li> </ul> </li> </ul> </li> </ul> </li> <li>domain<ul> <li>pipelines<ul> <li>schemas</li> </ul> </li> <li>xkcd<ul> <li>comic<ul> <li>models</li> <li>repository</li> <li>schemas</li> </ul> </li> </ul> </li> </ul> </li> <li>helpers<ul> <li>data_ctl<ul> <li>context_managers<ul> <li>file<ul> <li>handlers</li> </ul> </li> </ul> </li> <li>methods</li> </ul> </li> <li>validators<ul> <li>path_validators<ul> <li>_validators</li> </ul> </li> <li>requests_validators<ul> <li>_validators</li> </ul> </li> <li>xkcd_validators<ul> <li>comic_validators</li> </ul> </li> </ul> </li> </ul> </li> <li>main</li> <li>modules<ul> <li>requests_prefab<ul> <li>_reqs</li> </ul> </li> <li>xkcd_mod<ul> <li>methods</li> <li>response_handler<ul> <li>methods</li> </ul> </li> </ul> </li> </ul> </li> <li>packages<ul> <li>xkcd_comic<ul> <li>comic<ul> <li>methods</li> <li>scraper</li> </ul> </li> <li>current_comic<ul> <li>methods</li> </ul> </li> </ul> </li> </ul> </li> <li>pipelines<ul> <li>comic_pipelines<ul> <li>_pipelines</li> </ul> </li> </ul> </li> <li>start_current_comic_pipeline</li> <li>start_multiple_comic_pipeline</li> <li>start_scrape_missing_pipeline</li> <li>test</li> <li>utils<ul> <li>list_utils<ul> <li>methods</li> </ul> </li> <li>serialize_utils<ul> <li>methods</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/auto_xkcd/__init__/","title":"auto_xkcd","text":"<p>Methods &amp; pipelines for interacting with the XKCD API.</p>"},{"location":"reference/auto_xkcd/_setup/","title":"_setup","text":"<p>Methods meant to be called early during execution.</p> <p>Handle setup tasks, like creating directories that must exist, initializing logging, etc.</p>"},{"location":"reference/auto_xkcd/_setup/#auto_xkcd._setup.base_app_setup","title":"<code>base_app_setup(settings=settings, ensure_dirs=ENSURE_DIRS)</code>","text":"<p>Run setup methods.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>AppSettings</code> <p>An initialized instance of AppSettings.</p> <code>settings</code> <code>ensure_dirs</code> <code>list[Path]</code> <p>A list of <code>Path</code> values to loop over and create, if they do not exist.</p> <code>ENSURE_DIRS</code> Source code in <code>src/auto_xkcd/_setup.py</code> <pre><code>def base_app_setup(\n    settings: AppSettings = settings, ensure_dirs: list[Path] = ENSURE_DIRS\n) -&gt; None:\n    \"\"\"Run setup methods.\n\n    Params:\n        settings (AppSettings): An initialized instance of AppSettings.\n        ensure_dirs (list[Path]): A list of `Path` values to loop over and create, if they do not exist.\n\n    \"\"\"\n    assert settings, ValueError(\"Missing AppSettings object\")\n    assert isinstance(settings, AppSettings), TypeError(\n        f\"settings must be of type AppSettings. Got type: ({type(settings)})\"\n    )\n\n    assert ensure_dirs, ValueError(\"Missing list of directories to ensure existence\")\n    assert isinstance(ensure_dirs, list), TypeError(\n        f\"ensure_dirs must be a list of Path objects\"\n    )\n\n    logging_setup(settings=settings)\n    setup_ensure_dirs(ensure_dirs=ensure_dirs)\n</code></pre>"},{"location":"reference/auto_xkcd/_setup/#auto_xkcd._setup.logging_setup","title":"<code>logging_setup(settings=settings, sinks=DEFAULT_LOGGING_SINKS)</code>","text":"<p>Initialize app logging (with Loguru).</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>AppSettings</code> <p>An initialized instance of <code>AppSettings</code>.</p> <code>settings</code> <code>sinks</code> <code>list</code> <p>A list of <code>loguru</code> sink dicts for the global logger.</p> <code>DEFAULT_LOGGING_SINKS</code> Source code in <code>src/auto_xkcd/_setup.py</code> <pre><code>def logging_setup(\n    settings: AppSettings = settings, sinks: list = DEFAULT_LOGGING_SINKS\n) -&gt; None:\n    \"\"\"Initialize app logging (with Loguru).\n\n    Params:\n        settings (AppSettings): An initialized instance of `AppSettings`.\n        sinks (list): A list of `loguru` sink dicts for the global logger.\n    \"\"\"\n    assert settings, ValueError(\"Missing AppSettings object\")\n    assert isinstance(settings, AppSettings), TypeError(\n        f\"settings must be of type AppSettings. Got type: ({type(settings)})\"\n    )\n\n    init_logger(sinks=sinks)\n    log.info(\"Logging initialized\")\n</code></pre>"},{"location":"reference/auto_xkcd/_setup/#auto_xkcd._setup.setup_ensure_dirs","title":"<code>setup_ensure_dirs(ensure_dirs=ENSURE_DIRS)</code>","text":"<p>Loop over list of Paths, create them if they do not exist.</p> <p>Parameters:</p> Name Type Description Default <code>ensure_dirs</code> <code>list[Path]</code> <p>A list of <code>Path</code> values to loop over &amp; create, if they do not exist.</p> <code>ENSURE_DIRS</code> Source code in <code>src/auto_xkcd/_setup.py</code> <pre><code>def setup_ensure_dirs(ensure_dirs: list[Path] = ENSURE_DIRS) -&gt; None:\n    \"\"\"Loop over list of Paths, create them if they do not exist.\n\n    Params:\n        ensure_dirs (list[Path]): A list of `Path` values to loop over &amp; create, if they do not exist.\n    \"\"\"\n    try:\n        path_utils.ensure_dirs_exist(ensure_dirs=ensure_dirs)\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception ensuring directories exist. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/main/","title":"main","text":""},{"location":"reference/auto_xkcd/start_current_comic_pipeline/","title":"start_current_comic_pipeline","text":"<p>Entrypoint for the pipeline that requests the current XKCD comic.</p> <p>If the current XKCD comic has been requested recently, re-use the response until it is \"stale.\"</p>"},{"location":"reference/auto_xkcd/start_current_comic_pipeline/#auto_xkcd.start_current_comic_pipeline.run_pipeline","title":"<code>run_pipeline(cache_transport=None)</code>","text":"<p>Run the pipeline that requests the current XKCD comic.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport for the request client.</p> <code>None</code> <p>Returns:</p> Type Description <code>XKCDComic</code> <p>An <code>XKCDComic</code> object of the current live XKCD comic.</p> Source code in <code>src/auto_xkcd/start_current_comic_pipeline.py</code> <pre><code>def run_pipeline(cache_transport: hishel.CacheTransport = None) -&gt; XKCDComic:\n    \"\"\"Run the pipeline that requests the current XKCD comic.\n\n    Params:\n        cache_transport (hishel.CacheTransport): A cache transport for the request client.\n\n    Returns:\n        (XKCDComic): An `XKCDComic` object of the current live XKCD comic.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n\n    current_comic: XKCDComic = comic_pipelines.pipeline_current_comic(\n        cache_transport=CACHE_TRANSPORT\n    )\n    log.debug(f\"Current comic ({type(current_comic)}): {current_comic}\")\n\n    return current_comic\n</code></pre>"},{"location":"reference/auto_xkcd/start_multiple_comic_pipeline/","title":"start_multiple_comic_pipeline","text":"<p>Entrypoint for the pipeline that requests multiple XKCD comics in a group.</p> <p>Warning</p> <p>Make sure you configure a <code>request_sleep</code> limit for this pipeline. It's rude to spam XKCD's API!</p>"},{"location":"reference/auto_xkcd/start_multiple_comic_pipeline/#auto_xkcd.start_multiple_comic_pipeline.run_pipeline","title":"<code>run_pipeline(cache_transport=None, comic_nums=None, overwrite_serialized_comic=False, request_sleep=5)</code>","text":"<p>Start the pipeline to download multiple XKCD comics.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>The cache transport for the request client.</p> <code>None</code> <code>comic_nums</code> <code>list[int]</code> <p>A list of <code>int</code> values representing XKCD comic numbers.</p> <code>None</code> <code>request_sleep</code> <code>int</code> <p>Number of seconds to sleep between requests.</p> <code>5</code> <code>overwrite_serialized_comic</code> <code>bool</code> <p>If <code>True</code>, functions that request a comic will overwrite saved serialized data, if it exists.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[XKCDComic]</code> <p>A list of <code>XKCDComic</code> objects.</p> Source code in <code>src/auto_xkcd/start_multiple_comic_pipeline.py</code> <pre><code>def run_pipeline(\n    cache_transport: hishel.CacheTransport = None,\n    comic_nums: list[int] = None,\n    overwrite_serialized_comic: bool = False,\n    request_sleep: int = 5,\n) -&gt; XKCDComic:\n    \"\"\"Start the pipeline to download multiple XKCD comics.\n\n    Params:\n        cache_transport (hishel.CacheTransport): The cache transport for the request client.\n        comic_nums (list[int]): A list of `int` values representing XKCD comic numbers.\n        request_sleep (int): Number of seconds to sleep between requests.\n        overwrite_serialized_comic (bool): If `True`, functions that request a comic will overwrite saved\n            serialized data, if it exists.\n\n    Returns:\n        (list[XKCDComic]): A list of `XKCDComic` objects.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n    comic_nums = validate_comic_nums_lst(comic_nums=comic_nums)\n\n    current_comic: XKCDComic = comic_pipelines.pipeline_multiple_comics(\n        cache_transport=cache_transport,\n        comic_nums=comic_nums,\n        overwrite_serialized_comic=overwrite_serialized_comic,\n        request_sleep=request_sleep,\n    )\n    log.debug(f\"Current comic ({type(current_comic)}): {current_comic}\")\n\n    return current_comic\n</code></pre>"},{"location":"reference/auto_xkcd/start_scrape_missing_pipeline/","title":"start_scrape_missing_pipeline","text":"<p>Entrypoint for the pipeline that scrapes XKCD's API for missing comics.</p> <p>Warning</p> <p>Make sure you configure a <code>request_sleep</code> limit for this pipeline. It's rude to spam XKCD's API!</p>"},{"location":"reference/auto_xkcd/start_scrape_missing_pipeline/#auto_xkcd.start_scrape_missing_pipeline.run_pipeline","title":"<code>run_pipeline(cache_transport=None, request_sleep=5, overwrite_serialized_comic=False, max_list_size=50, loop_limit=None)</code>","text":"<p>Start the pipeline to scrape for missing XKCD comics.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>The cache transport for the request client.</p> <code>None</code> <code>request_sleep</code> <code>int</code> <p>Number of seconds to sleep between requests.</p> <code>5</code> <code>overwrite_serialized_comic</code> <code>bool</code> <p>If <code>True</code>, functions that request a comic will overwrite saved serialized data, if it exists.</p> <code>False</code> <code>max_list_size</code> <code>int</code> <p>[Default: 50] If the list of missing comics exceeds <code>max_list_size</code>, list will be broken into smaller \"chunks,\" where each new list will be smaller in size than <code>max_list_size</code>.</p> <code>50</code> <code>loop_limit</code> <code>int | None</code> <p>If set to an integer value, scraping will be limited to the number of loops defined in <code>loop_limit</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[XKCDComic]</code> <p>A list of <code>XKCDComic</code> objects.</p> Source code in <code>src/auto_xkcd/start_scrape_missing_pipeline.py</code> <pre><code>def run_pipeline(\n    cache_transport: hishel.CacheTransport = None,\n    request_sleep: int = 5,\n    overwrite_serialized_comic: bool = False,\n    max_list_size: int = 50,\n    loop_limit: int | None = None,\n) -&gt; list[XKCDComic]:\n    \"\"\"Start the pipeline to scrape for missing XKCD comics.\n\n    Params:\n        cache_transport (hishel.CacheTransport): The cache transport for the request client.\n        request_sleep (int): Number of seconds to sleep between requests.\n        overwrite_serialized_comic (bool): If `True`, functions that request a comic will overwrite saved\n            serialized data, if it exists.\n        max_list_size (int): [Default: 50] If the list of missing comics exceeds `max_list_size`, list will be\n            broken into smaller \"chunks,\" where each new list will be smaller in size than `max_list_size`.\n        loop_limit (int|None): If set to an integer value, scraping will be limited to the number of loops defined in `loop_limit`.\n\n    Returns:\n        (list[XKCDComic]): A list of `XKCDComic` objects.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n\n    scraped_comics: list[XKCDComic] = comic_pipelines.pipeline_scrape_missing_comics(\n        cache_transport=cache_transport,\n        request_sleep=request_sleep,\n        overwrite_serialized_comic=overwrite_serialized_comic,\n        max_list_size=max_list_size,\n        loop_limit=loop_limit,\n    )\n\n    return scraped_comics\n</code></pre>"},{"location":"reference/auto_xkcd/test/","title":"test","text":"<p>A temporary testing ground for new features. New pipelines are created from the starting point here. This file will eventually be removed.</p>"},{"location":"reference/auto_xkcd/core/__init__/","title":"core","text":"<p>The <code>core</code> module stores globally accessible objects.</p> <p>Configuration classes are defined here, as well as base database setup &amp; some default variables for things like directory paths &amp; file paths.</p> <p>Code in this module should not import from outside the <code>core</code> directory, if possible.</p>"},{"location":"reference/auto_xkcd/core/config/","title":"config","text":""},{"location":"reference/auto_xkcd/core/config/#auto_xkcd.core.config.AppSettings","title":"<code>AppSettings</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Store application configuration values.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>str</code> <p>Usually <code>prod</code> or <code>dev</code>.</p> required <code>container_env</code> <code>bool</code> <p>If running in a container, you can set an env variable <code>DYNACONF_CONTAINER_ENV=True</code> to indicate the app is running in a container. This can be useful for controlling certain behaviors when running in a container.</p> required <code>log_level</code> <code>str</code> <p>Control logging level. i.e. <code>\"INFO\"</code>, <code>\"DEBUG\"</code>, <code>\"WARNING\"</code>, etc</p> required <code>logs_dir</code> <code>str | Path</code> <p>The directory where logs will be stored, if file logging is enabled.</p> required Source code in <code>src/auto_xkcd/core/config.py</code> <pre><code>class AppSettings(BaseSettings):\n    \"\"\"Store application configuration values.\n\n    Params:\n        env (str): Usually `prod` or `dev`.\n        container_env (bool): If running in a container, you can set an env variable\n            `DYNACONF_CONTAINER_ENV=True` to indicate the app is running in a container.\n            This can be useful for controlling certain behaviors when running in a container.\n        log_level (str): Control logging level. i.e. `\"INFO\"`, `\"DEBUG\"`, `\"WARNING\"`, etc\n        logs_dir (str|Path): The directory where logs will be stored, if file logging is enabled.\n    \"\"\"\n\n    env: str = Field(default=\"prod\", env=\"ENV\")\n    container_env: bool = Field(default=False, env=\"CONTAINER_ENV\")\n    log_level: str = Field(default=\"INFO\", env=\"LOG_LEVEL\")\n    logs_dir: t.Union[str, Path] = Field(default=\"logs\", env=\"LOGS_DIR\")\n\n    @field_validator(\"logs_dir\")\n    def validate_logs_dir(cls, v) -&gt; Path:\n        if isinstance(v, str):\n            if \"~\" in v:\n                return Path(v).expanduser()\n            else:\n                return Path(v)\n\n        if isinstance(v, Path):\n            if \"~\" in f\"{v}\":\n                return v.expanduser()\n            else:\n                return v\n\n        raise ValidationError\n\n    @field_validator(\"log_level\")\n    def validate_log_level(cls, v) -&gt; str:\n        if isinstance(v, str):\n            return v.upper()\n\n        raise ValidationError\n</code></pre>"},{"location":"reference/auto_xkcd/core/config/#auto_xkcd.core.config.DBSettings","title":"<code>DBSettings</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Store database configuration values.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>The database type, i.e. <code>'sqlite'</code>.</p> required <code>drivername</code> <code>str</code> <p>The <code>sqlalchemy</code> driver name, i.e. <code>'sqlite+pysqlite'</code>.</p> required <code>username</code> <code>str | None</code> <p>The database user's username.</p> required <code>password</code> <code>str | None</code> <p>The database user's password.</p> required <code>host</code> <code>str | None</code> <p>The database host address.</p> required <code>port</code> <code>str | int | None</code> <p>The database host's port.</p> required <code>database</code> <code>str</code> <p>The name of the database to connect to. For SQLite, use the path to the file, i.e. <code>db/app.sqlite</code>.</p> required <code>echo</code> <code>bool</code> <p>If <code>True</code>, the SQLAlchemy <code>Engine</code> will echo SQL queries to the CLI, and will create tables that do not exist (if possible).</p> required Source code in <code>src/auto_xkcd/core/config.py</code> <pre><code>class DBSettings(BaseSettings):\n    \"\"\"Store database configuration values.\n\n    Params:\n        type (str): The database type, i.e. `'sqlite'`.\n        drivername (str): The `sqlalchemy` driver name, i.e. `'sqlite+pysqlite'`.\n        username (str|None): The database user's username.\n        password (str|None): The database user's password.\n        host (str|None): The database host address.\n        port (str|int|None): The database host's port.\n        database (str): The name of the database to connect to. For SQLite, use the path to the file,\n            i.e. `db/app.sqlite`.\n        echo (bool): If `True`, the SQLAlchemy `Engine` will echo SQL queries to the CLI, and will create tables\n            that do not exist (if possible).\n\n    \"\"\"\n\n    type: str = Field(\n        default=\"sqlite\",\n        description=\"The type of database this configuration defines.\",\n        env=\"DB_TYPE\",\n    )\n    drivername: str = Field(\n        default=\"sqlite+pysqlite\",\n        description=\"The SQLAlchemy drivername string.\",\n        env=\"DB_DRIVERNAME\",\n    )\n    username: str | None = Field(\n        default=None,\n        description=\"The username for database authentication.\",\n        env=\"DB_USERNAME\",\n    )\n    password: str | None = Field(\n        default=None,\n        description=\"The pasword for database authentication.\",\n        env=\"DB_PASSWORD\",\n        repr=False,\n    )\n    host: str | None = Field(\n        default=None,\n        description=\"The host address of the database server.\",\n        env=\"DB_HOST\",\n    )\n    port: t.Union[str, int, None] = Field(\n        default=None, description=\"The port of the database server.\", env=\"DB_PORT\"\n    )\n    database: str = Field(\n        default=\"auto-xkcd.sqlite\",\n        description=\"The database to connect to.\",\n        env=\"DB_DATABASE\",\n    )\n    echo: bool = Field(\n        default=True,\n        description=\"Configure the SQLAlchemy `Engine`'s echo truthiness.\",\n        env=\"DB_ECHO\",\n    )\n\n    @field_validator(\"port\")\n    def validate_db_port(cls, v) -&gt; int:\n        if v is None or v == \"\":\n            return None\n        elif isinstance(v, int):\n            return v\n        elif isinstance(v, str):\n            return int(v)\n        else:\n            raise ValidationError\n\n    def get_db_uri(self) -&gt; sa.URL:\n        try:\n            _uri: sa.URL = sa.URL.create(\n                drivername=self.drivername,\n                username=self.username,\n                password=self.password,\n                host=self.host,\n                port=self.port,\n                database=self.database,\n            )\n\n            return _uri\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting SQLAlchemy database URL. Details: {exc}\"\n            )\n            raise msg\n\n    def get_engine(self) -&gt; sa.Engine:\n        \"\"\"Build &amp; return a SQLAlchemy `Engine`.\n\n        Returns:\n            `sqlalchemy.Engine`: A SQLAlchemy `Engine` instance.\n\n        \"\"\"\n        assert self.get_db_uri() is not None, ValueError(\"db_uri is not None\")\n        assert isinstance(self.get_db_uri(), sa.URL), TypeError(\n            f\"db_uri must be of type sqlalchemy.URL. Got type: ({type(self.db_uri)})\"\n        )\n\n        try:\n            engine: sa.Engine = sa.create_engine(\n                url=self.get_db_uri().render_as_string(hide_password=False),\n                echo=self.echo,\n            )\n\n            return engine\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting database engine. Details: {exc}\"\n            )\n\n            raise msg\n\n    def get_session_pool(self) -&gt; so.sessionmaker[so.Session]:\n        \"\"\"Configure a session pool using class's SQLAlchemy `Engine`.\n\n        Returns:\n            (sqlalchemy.orm.sessionmaker): A SQLAlchemy `Session` pool for database connections.\n\n        \"\"\"\n        engine: sa.Engine = self.get_engine()\n        assert engine is not None, ValueError(\"engine cannot be None\")\n        assert isinstance(engine, sa.Engine), TypeError(\n            f\"engine must be of type sqlalchemy.Engine. Got type: ({type(engine)})\"\n        )\n\n        session_pool: so.sessionmaker[so.Session] = so.sessionmaker(bind=engine)\n\n        return session_pool\n</code></pre>"},{"location":"reference/auto_xkcd/core/config/#auto_xkcd.core.config.DBSettings.get_engine","title":"<code>get_engine()</code>","text":"<p>Build &amp; return a SQLAlchemy <code>Engine</code>.</p> <p>Returns:</p> Type Description <code>Engine</code> <p><code>sqlalchemy.Engine</code>: A SQLAlchemy <code>Engine</code> instance.</p> Source code in <code>src/auto_xkcd/core/config.py</code> <pre><code>def get_engine(self) -&gt; sa.Engine:\n    \"\"\"Build &amp; return a SQLAlchemy `Engine`.\n\n    Returns:\n        `sqlalchemy.Engine`: A SQLAlchemy `Engine` instance.\n\n    \"\"\"\n    assert self.get_db_uri() is not None, ValueError(\"db_uri is not None\")\n    assert isinstance(self.get_db_uri(), sa.URL), TypeError(\n        f\"db_uri must be of type sqlalchemy.URL. Got type: ({type(self.db_uri)})\"\n    )\n\n    try:\n        engine: sa.Engine = sa.create_engine(\n            url=self.get_db_uri().render_as_string(hide_password=False),\n            echo=self.echo,\n        )\n\n        return engine\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception getting database engine. Details: {exc}\"\n        )\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/config/#auto_xkcd.core.config.DBSettings.get_session_pool","title":"<code>get_session_pool()</code>","text":"<p>Configure a session pool using class's SQLAlchemy <code>Engine</code>.</p> <p>Returns:</p> Type Description <code>sessionmaker</code> <p>A SQLAlchemy <code>Session</code> pool for database connections.</p> Source code in <code>src/auto_xkcd/core/config.py</code> <pre><code>def get_session_pool(self) -&gt; so.sessionmaker[so.Session]:\n    \"\"\"Configure a session pool using class's SQLAlchemy `Engine`.\n\n    Returns:\n        (sqlalchemy.orm.sessionmaker): A SQLAlchemy `Session` pool for database connections.\n\n    \"\"\"\n    engine: sa.Engine = self.get_engine()\n    assert engine is not None, ValueError(\"engine cannot be None\")\n    assert isinstance(engine, sa.Engine), TypeError(\n        f\"engine must be of type sqlalchemy.Engine. Got type: ({type(engine)})\"\n    )\n\n    session_pool: so.sessionmaker[so.Session] = so.sessionmaker(bind=engine)\n\n    return session_pool\n</code></pre>"},{"location":"reference/auto_xkcd/core/config/#auto_xkcd.core.config.MinioSettings","title":"<code>MinioSettings</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Store minio configuration values.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The address of the minio server.</p> required <code>port</code> <code>int</code> <p>The port of the minio server.</p> required <code>secure</code> <code>bool</code> <p>Whether or not to connect over HTTPS.</p> required <code>username</code> <code>str</code> <p>The username to authenticate with.</p> required <code>password</code> <code>str</code> <p>The password to authenticate with.</p> required <code>access_key</code> <code>str</code> <p>The API key value.</p> required <code>access_secret</code> <code>str</code> <p>The  API key secret.</p> required Source code in <code>src/auto_xkcd/core/config.py</code> <pre><code>class MinioSettings(BaseSettings):\n    \"\"\"Store minio configuration values.\n\n    Params:\n        address (str): The address of the minio server.\n        port (int): The port of the minio server.\n        secure (bool): Whether or not to connect over HTTPS.\n        username (str): The username to authenticate with.\n        password (str): The password to authenticate with.\n        access_key (str): The API key value.\n        access_secret (str): The  API key secret.\n    \"\"\"\n\n    address: str = Field(default=None, env=\"MINIO_ADDRESS\")\n    port: int = Field(default=9000, env=\"MINIO_PORT\")\n    secure: bool = Field(default=True, env=\"MINIO_HTTPS\")\n    username: str = Field(default=None, env=\"MINIO_USERNAME\")\n    password: str = Field(default=None, env=\"MINIO_PASSWORD\", repr=False)\n    access_key: str = Field(default=None, env=\"MINIO_ACCESS_KEY\")\n    access_secret: str = Field(default=None, env=\"MINIO_ACCESS_SECRET\", repr=False)\n\n    @property\n    def endpoint(self) -&gt; str:\n        return f\"{self.address}:{self.port}\"\n</code></pre>"},{"location":"reference/auto_xkcd/core/config/#auto_xkcd.core.config.TelegramSettings","title":"<code>TelegramSettings</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Configuration values for Telegram messaging.</p> <p>Parameters:</p> Name Type Description Default <code>bot_token</code> <code>str</code> <p>The Telegram bot's token.</p> required <code>bot_username(</code> <code>str</code> <p>The Telegram bot's username.</p> required Source code in <code>src/auto_xkcd/core/config.py</code> <pre><code>class TelegramSettings(BaseSettings):\n    \"\"\"Configuration values for Telegram messaging.\n\n    Params:\n        bot_token (str): The Telegram bot's token.\n        bot_username( str): The Telegram bot's username.\n    \"\"\"\n\n    bot_token: str | None = Field(default=None, env=\"TELEGRAM_BOT_TOKEN\")\n    bot_username: str | None = Field(default=None, env=\"TELEGRAM_BOT_USERNAME\")\n</code></pre>"},{"location":"reference/auto_xkcd/core/constants/","title":"constants","text":"<p>Define global constants for modules/packages to use.</p> <p>Includes values like <code>IGNORE_COMIC_NUMS</code>, which is a list of integers representing comic numbers to ignore. This is useful to ignore joke comics like comic #404, which returns an HTTP 404 response as a joke.</p>"},{"location":"reference/auto_xkcd/core/dependencies/","title":"dependencies","text":"<p>Importable dependencies for the app.</p> <p>Includes initialized <code>Dynaconf</code> settings objects, initialized SQLAlchemy variables, and methods/context managers for yielding objects like a database connection.</p>"},{"location":"reference/auto_xkcd/core/dependencies/#auto_xkcd.core.dependencies.get_db","title":"<code>get_db()</code>","text":"<p>Dependency to yield a SQLAlchemy Session pool.</p> <p>Usage:</p> get_db() dependency usage<pre><code>from core.dependencies import get_db\n\nwith get_db() as session:\n    repo = someRepoClass(session)\n\n    all = repo.get_all()\n</code></pre> Source code in <code>src/auto_xkcd/core/dependencies.py</code> <pre><code>@contextmanager\ndef get_db() -&gt; t.Generator[so.Session, t.Any, None]:\n    \"\"\"Dependency to yield a SQLAlchemy Session pool.\n\n    Usage:\n\n    ```py title=\"get_db() dependency usage\" linenums=\"1\"\n\n    from core.dependencies import get_db\n\n    with get_db() as session:\n        repo = someRepoClass(session)\n\n        all = repo.get_all()\n    ```\n    \"\"\"\n    db: so.Session = SESSION_POOL()\n\n    try:\n        yield db\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception yielding database session. Details: {exc}\"\n        )\n\n        raise msg\n    finally:\n        db.close()\n</code></pre>"},{"location":"reference/auto_xkcd/core/paths/","title":"paths","text":"<p>Pre-defined paths for the app.</p> <p>Also includes a list of <code>Path</code>s called <code>ENSURE_DIRS</code>. Directories in this list will be created at app startup.</p>"},{"location":"reference/auto_xkcd/core/database/__init__/","title":"database","text":"<p>The database module is the basis for database operations.</p> <p>The SQLAlchemy <code>DeclarativeBase</code> object is defined here, and methods for creating base metadata, getting a database engine, etc are defined here.</p> <p>This module also has useful mixins/addons for SQLAlchemy, like annotated columns for an <code>INT_PK</code>, or a <code>VARCHAR(10)</code> column type defined in <code>STR_10</code>.</p> <p>Mixin classes for SQLAlchemy model classes, like <code>TimestampMixin</code>, automatically add columns &amp; values to models stored in the database.</p>"},{"location":"reference/auto_xkcd/core/database/base/","title":"base","text":"<p>Define the SQLAlchemy <code>DeclarativeBase</code> object.</p>"},{"location":"reference/auto_xkcd/core/database/base/#auto_xkcd.core.database.base.Base","title":"<code>Base</code>","text":"<p>             Bases: <code>DeclarativeBase</code></p> <p>Initialize a SQLAlchemy <code>DeclarativeBase</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>registry</code> <p> required <code>metadata</code> <code>MetaData</code> <p> required Source code in <code>src/auto_xkcd/core/database/base.py</code> <pre><code>class Base(so.DeclarativeBase):\n    \"\"\"Initialize a SQLAlchemy `DeclarativeBase` instance.\n\n    Params:\n        registry (sqalchemy.orm.registry): &lt;Not documented&gt;\n        metadata (sqlalchemy.MetaData): &lt;Not documented&gt;\n\n    \"\"\"\n\n    registry: so.registry = REGISTRY\n    metadata: sa.MetaData = METADATA\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/db_config/","title":"db_config","text":"<p>Contained database configuration class.</p> <p>The <code>DBSettings</code> defined in <code>core.config</code> is generic. The <code>DBSettings</code> defined in this module can be configured/tweaked for this specific project.</p>"},{"location":"reference/auto_xkcd/core/database/db_config/#auto_xkcd.core.database.db_config.DBSettings","title":"<code>DBSettings</code>  <code>dataclass</code>","text":"<p>Store configuration for a database.</p> <p>Parameters:</p> Name Type Description Default <code>drivername</code> <code>str</code> <p>The <code>sqlalchemy</code> driver name, i.e. <code>'sqlite+pysqlite'</code>.</p> <code>'sqlite+pysqlite'</code> <code>user</code> <code>str | None</code> <p>The database user's username.</p> <code>None</code> <code>password</code> <code>str | None</code> <p>The database user's password.</p> <code>None</code> <code>host</code> <code>str | None</code> <p>The database host address.</p> <code>None</code> <code>port</code> <code>str | int | None</code> <p>The database host's port.</p> <code>None</code> <code>database</code> <code>str</code> <p>The name of the database to connect to. For SQLite, use the path to the file, i.e. <code>db/app.sqlite</code>.</p> <code>'app.sqlite'</code> <code>echo</code> <code>bool</code> <p>If <code>True</code>, the SQLAlchemy <code>Engine</code> will echo SQL queries to the CLI, and will create tables that do not exist (if possible).</p> <code>False</code> Source code in <code>src/auto_xkcd/core/database/db_config.py</code> <pre><code>@dataclass\nclass DBSettings:\n    \"\"\"Store configuration for a database.\n\n    Params:\n        drivername (str): The `sqlalchemy` driver name, i.e. `'sqlite+pysqlite'`.\n        user (str|None): The database user's username.\n        password (str|None): The database user's password.\n        host (str|None): The database host address.\n        port (str|int|None): The database host's port.\n        database (str): The name of the database to connect to. For SQLite, use the path to the file,\n            i.e. `db/app.sqlite`.\n        echo (bool): If `True`, the SQLAlchemy `Engine` will echo SQL queries to the CLI, and will create tables\n            that do not exist (if possible).\n\n    \"\"\"\n\n    drivername: str = field(default=\"sqlite+pysqlite\")\n    user: str | None = field(default=None)\n    password: str | None = field(default=None)\n    host: str | None = field(default=None)\n    port: str | None = field(default=None)\n    database: str = field(default=\"app.sqlite\")\n    echo: bool = field(default=False)\n\n    def __post_init__(self):\n        assert self.drivername is not None, ValueError(\"drivername cannot be None\")\n        assert isinstance(self.drivername, str), TypeError(\n            f\"drivername must be of type str. Got type: ({type(self.drivername)})\"\n        )\n        assert isinstance(self.echo, bool), TypeError(\n            f\"echo must be a bool. Got type: ({type(self.echo)})\"\n        )\n        if self.user:\n            assert isinstance(self.user, str), TypeError(\n                f\"user must be of type str. Got type: ({type(self.user)})\"\n            )\n        if self.password:\n            assert isinstance(self.password, str), TypeError(\n                f\"password must be of type str. Got type: ({type(self.password)})\"\n            )\n        if self.host:\n            assert isinstance(self.host, str), TypeError(\n                f\"host must be of type str. Got type: ({type(self.host)})\"\n            )\n        if self.port:\n            assert isinstance(self.port, int), TypeError(\n                f\"port must be of type int. Got type: ({type(self.port)})\"\n            )\n            assert self.port &gt; 0 and self.port &lt;= 65535, ValueError(\n                f\"port must be an integer between 1 and 65535\"\n            )\n        if self.database:\n            assert isinstance(self.database, Path) or isinstance(\n                self.database, str\n            ), TypeError(\n                f\"database must be of type str or Path. Got type: ({type(self.database)})\"\n            )\n            if isinstance(self.database, Path):\n                self.database: str = f\"{self.database}\"\n\n    def get_db_uri(self) -&gt; sa.URL:\n        \"\"\"Construct a SQLAlchemy `URL` from class params.\n\n        Returns:\n            (sqlalchemy.URL): An initialized database connection URL.\n\n        \"\"\"\n        try:\n            _uri: sa.URL = sa.URL.create(\n                drivername=self.drivername,\n                username=self.user,\n                password=self.password,\n                host=self.host,\n                port=self.port,\n                database=self.database,\n            )\n\n            return _uri\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting SQLAlchemy database URL. Details: {exc}\"\n            )\n            raise msg\n\n    def get_engine(self) -&gt; sa.Engine:\n        \"\"\"Build &amp; return a SQLAlchemy `Engine`.\n\n        Returns:\n            `sqlalchemy.Engine`: A SQLAlchemy `Engine` instance.\n\n        \"\"\"\n        assert self.get_db_uri() is not None, ValueError(\"db_uri is not None\")\n        assert isinstance(self.get_db_uri(), sa.URL), TypeError(\n            f\"db_uri must be of type sqlalchemy.URL. Got type: ({type(self.db_uri)})\"\n        )\n\n        try:\n            engine: sa.Engine = sa.create_engine(\n                url=self.get_db_uri().render_as_string(hide_password=False),\n                echo=self.echo,\n            )\n\n            return engine\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting database engine. Details: {exc}\"\n            )\n\n            raise msg\n\n    def get_session_pool(self) -&gt; so.sessionmaker[so.Session]:\n        \"\"\"Configure a session pool using class's SQLAlchemy `Engine`.\n\n        Returns:\n            (sqlalchemy.orm.sessionmaker): A SQLAlchemy `Session` pool for database connections.\n\n        \"\"\"\n        engine: sa.Engine = self.get_engine()\n        assert engine is not None, ValueError(\"engine cannot be None\")\n        assert isinstance(engine, sa.Engine), TypeError(\n            f\"engine must be of type sqlalchemy.Engine. Got type: ({type(engine)})\"\n        )\n\n        session_pool: so.sessionmaker[so.Session] = so.sessionmaker(bind=engine)\n\n        return session_pool\n\n    @contextmanager\n    def get_db(self) -&gt; t.Generator[so.Session, t.Any, None]:\n        \"\"\"Context manager class to handle a SQLAlchemy Session pool.\n\n        Usage:\n\n        ```py title=\"get_db() dependency usage\" linenums=\"1\"\n\n        ## Assumes `db_settings` is an initialized instance of `DBSettings`.\n        with db_settings.get_db() as session:\n            repo = someRepoClass(session)\n\n            all = repo.get_all()\n        ```\n        \"\"\"\n        db: so.Session = self.get_session_pool()\n\n        try:\n            yield db\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception yielding database session. Details: {exc}\"\n            )\n\n            raise msg\n        finally:\n            db.close()\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/db_config/#auto_xkcd.core.database.db_config.DBSettings.get_db","title":"<code>get_db()</code>","text":"<p>Context manager class to handle a SQLAlchemy Session pool.</p> <p>Usage:</p> get_db() dependency usage<pre><code>## Assumes `db_settings` is an initialized instance of `DBSettings`.\nwith db_settings.get_db() as session:\n    repo = someRepoClass(session)\n\n    all = repo.get_all()\n</code></pre> Source code in <code>src/auto_xkcd/core/database/db_config.py</code> <pre><code>@contextmanager\ndef get_db(self) -&gt; t.Generator[so.Session, t.Any, None]:\n    \"\"\"Context manager class to handle a SQLAlchemy Session pool.\n\n    Usage:\n\n    ```py title=\"get_db() dependency usage\" linenums=\"1\"\n\n    ## Assumes `db_settings` is an initialized instance of `DBSettings`.\n    with db_settings.get_db() as session:\n        repo = someRepoClass(session)\n\n        all = repo.get_all()\n    ```\n    \"\"\"\n    db: so.Session = self.get_session_pool()\n\n    try:\n        yield db\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception yielding database session. Details: {exc}\"\n        )\n\n        raise msg\n    finally:\n        db.close()\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/db_config/#auto_xkcd.core.database.db_config.DBSettings.get_db_uri","title":"<code>get_db_uri()</code>","text":"<p>Construct a SQLAlchemy <code>URL</code> from class params.</p> <p>Returns:</p> Type Description <code>URL</code> <p>An initialized database connection URL.</p> Source code in <code>src/auto_xkcd/core/database/db_config.py</code> <pre><code>def get_db_uri(self) -&gt; sa.URL:\n    \"\"\"Construct a SQLAlchemy `URL` from class params.\n\n    Returns:\n        (sqlalchemy.URL): An initialized database connection URL.\n\n    \"\"\"\n    try:\n        _uri: sa.URL = sa.URL.create(\n            drivername=self.drivername,\n            username=self.user,\n            password=self.password,\n            host=self.host,\n            port=self.port,\n            database=self.database,\n        )\n\n        return _uri\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception getting SQLAlchemy database URL. Details: {exc}\"\n        )\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/db_config/#auto_xkcd.core.database.db_config.DBSettings.get_engine","title":"<code>get_engine()</code>","text":"<p>Build &amp; return a SQLAlchemy <code>Engine</code>.</p> <p>Returns:</p> Type Description <code>Engine</code> <p><code>sqlalchemy.Engine</code>: A SQLAlchemy <code>Engine</code> instance.</p> Source code in <code>src/auto_xkcd/core/database/db_config.py</code> <pre><code>def get_engine(self) -&gt; sa.Engine:\n    \"\"\"Build &amp; return a SQLAlchemy `Engine`.\n\n    Returns:\n        `sqlalchemy.Engine`: A SQLAlchemy `Engine` instance.\n\n    \"\"\"\n    assert self.get_db_uri() is not None, ValueError(\"db_uri is not None\")\n    assert isinstance(self.get_db_uri(), sa.URL), TypeError(\n        f\"db_uri must be of type sqlalchemy.URL. Got type: ({type(self.db_uri)})\"\n    )\n\n    try:\n        engine: sa.Engine = sa.create_engine(\n            url=self.get_db_uri().render_as_string(hide_password=False),\n            echo=self.echo,\n        )\n\n        return engine\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception getting database engine. Details: {exc}\"\n        )\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/db_config/#auto_xkcd.core.database.db_config.DBSettings.get_session_pool","title":"<code>get_session_pool()</code>","text":"<p>Configure a session pool using class's SQLAlchemy <code>Engine</code>.</p> <p>Returns:</p> Type Description <code>sessionmaker</code> <p>A SQLAlchemy <code>Session</code> pool for database connections.</p> Source code in <code>src/auto_xkcd/core/database/db_config.py</code> <pre><code>def get_session_pool(self) -&gt; so.sessionmaker[so.Session]:\n    \"\"\"Configure a session pool using class's SQLAlchemy `Engine`.\n\n    Returns:\n        (sqlalchemy.orm.sessionmaker): A SQLAlchemy `Session` pool for database connections.\n\n    \"\"\"\n    engine: sa.Engine = self.get_engine()\n    assert engine is not None, ValueError(\"engine cannot be None\")\n    assert isinstance(engine, sa.Engine), TypeError(\n        f\"engine must be of type sqlalchemy.Engine. Got type: ({type(engine)})\"\n    )\n\n    session_pool: so.sessionmaker[so.Session] = so.sessionmaker(bind=engine)\n\n    return session_pool\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/methods/","title":"methods","text":""},{"location":"reference/auto_xkcd/core/database/methods/#auto_xkcd.core.database.methods.create_base_metadata","title":"<code>create_base_metadata(base=None, engine=None)</code>","text":"<p>Create a SQLAlchemy base object's table metadata.</p> <p>Parameters:</p> Name Type Description Default <code>base</code> <code>DeclarativeBase</code> <p>A SQLAlchemy <code>DeclarativeBase</code> object to use for creating metadata.</p> <code>None</code> Source code in <code>src/auto_xkcd/core/database/methods.py</code> <pre><code>def create_base_metadata(\n    base: so.DeclarativeBase = None, engine: sa.Engine = None\n) -&gt; None:\n    \"\"\"Create a SQLAlchemy base object's table metadata.\n\n    Params:\n        base (sqlalchemy.orm.DeclarativeBase): A SQLAlchemy `DeclarativeBase` object to use for creating metadata.\n    \"\"\"\n    assert base is not None, ValueError(\"base cannot be None\")\n    # assert isinstance(base, so.DeclarativeBase), TypeError(\n    #     f\"base must be of type sqlalchemy.orm.DeclarativeBase. Got type: ({type(base)})\"\n    # )\n    assert engine is not None, ValueError(\"engine cannot be None\")\n    assert isinstance(engine, sa.Engine), TypeError(\n        f\"engine must be of type sqlalchemy.Engine. Got type: ({type(engine)})\"\n    )\n\n    try:\n        base.metadata.create_all(bind=engine)\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception creating Base metadata. Details: {exc}\")\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/methods/#auto_xkcd.core.database.methods.get_db_uri","title":"<code>get_db_uri(drivername='sqlite+pysqlite', username=None, password=None, host=None, port=None, database='demo.sqlite')</code>","text":"<p>Construct a SQLAlchemy <code>URL</code> for a database connection.</p> <p>Parameters:</p> Name Type Description Default <code>drivername</code> <code>str</code> <p>The SQLAlchemy drivername value, i.e. <code>sqlite+pysqlite</code>.</p> <code>'sqlite+pysqlite'</code> <code>username</code> <code>str | None</code> <p>The username for database auth.</p> <code>None</code> <code>password</code> <code>str | None</code> <p>The password for database auth.</p> <code>None</code> <code>host</code> <code>str | None</code> <p>The database server host address.</p> <code>None</code> <code>port</code> <code>int | None</code> <p>The database server port.</p> <code>None</code> <code>database</code> <code>str</code> <p>The database to connect to. For SQLite, use a file path, i.e. <code>path/to/app.sqlite</code>.</p> <code>'demo.sqlite'</code> Source code in <code>src/auto_xkcd/core/database/methods.py</code> <pre><code>def get_db_uri(\n    drivername: str = \"sqlite+pysqlite\",\n    username: str | None = None,\n    password: str | None = None,\n    host: str | None = None,\n    port: int | None = None,\n    database: str = \"demo.sqlite\",\n) -&gt; sa.URL:\n    \"\"\"Construct a SQLAlchemy `URL` for a database connection.\n\n    Params:\n        drivername (str): The SQLAlchemy drivername value, i.e. `sqlite+pysqlite`.\n        username (str|None): The username for database auth.\n        password (str|None): The password for database auth.\n        host (str|None): The database server host address.\n        port (int|None): The database server port.\n        database (str): The database to connect to. For SQLite, use a file path, i.e. `path/to/app.sqlite`.\n\n    \"\"\"\n    assert drivername is not None, ValueError(\"drivername cannot be None\")\n    assert isinstance(drivername, str), TypeError(\n        f\"drivername must be of type str. Got type: ({type(drivername)})\"\n    )\n    if username is not None:\n        assert isinstance(username, str), TypeError(\n            f\"username must be of type str. Got type: ({type(username)})\"\n        )\n    if password is not None:\n        assert isinstance(password, str), TypeError(\n            f\"password must be of type str. Got type: ({type(password)})\"\n        )\n    if host is not None:\n        assert isinstance(host, str), TypeError(\n            f\"host must be of type str. Got type: ({type(host)})\"\n        )\n    if port is not None:\n        assert isinstance(port, int), TypeError(\n            f\"port must be of type int. Got type: ({type(port)})\"\n        )\n    assert database is not None, ValueError(\"database cannot be None\")\n    assert isinstance(database, str), TypeError(\n        f\"database must be of type str. Got type: ({type(database)})\"\n    )\n\n    try:\n        db_uri: sa.URL = sa.URL.create(\n            drivername=drivername,\n            username=username,\n            password=password,\n            host=host,\n            port=port,\n            database=database,\n        )\n\n        return db_uri\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception creating SQLAlchemy URL from inputs. Details: {exc}\"\n        )\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/methods/#auto_xkcd.core.database.methods.get_engine","title":"<code>get_engine(db_uri=None, echo=False)</code>","text":"<p>Get a SQLAlchemy <code>Engine</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>db_uri</code> <code>URL</code> <p>A database connection string.</p> <code>None</code> <code>echo</code> <code>bool</code> <p>If <code>True</code>, engine will echo SQL output to CLI.</p> <code>False</code> <p>Returns:</p> Type Description <code>Engine</code> <p>An initialized SQLAlchemy <code>Engine</code>.</p> Source code in <code>src/auto_xkcd/core/database/methods.py</code> <pre><code>def get_engine(db_uri: sa.URL = None, echo: bool = False) -&gt; sa.Engine:\n    \"\"\"Get a SQLAlchemy `Engine` instance.\n\n    Params:\n        db_uri (sqlalchemy.URL): A database connection string.\n        echo (bool): If `True`, engine will echo SQL output to CLI.\n\n    Returns:\n        (sqlalchemy.Engine): An initialized SQLAlchemy `Engine`.\n\n    \"\"\"\n    assert db_uri is not None, ValueError(\"db_uri is not None\")\n    assert isinstance(db_uri, sa.URL), TypeError(\n        f\"db_uri must be of type sqlalchemy.URL. Got type: ({type(db_uri)})\"\n    )\n\n    try:\n        engine: sa.Engine = sa.create_engine(url=db_uri, echo=echo)\n\n        return engine\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception getting database engine. Details: {exc}\")\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/methods/#auto_xkcd.core.database.methods.get_session_pool","title":"<code>get_session_pool(engine=None)</code>","text":"<p>Return a SQLAlchemy session pool.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>Engine</code> <p>A SQLAlchemy <code>Engine</code> to use for database connections.</p> <code>None</code> <p>Returns:</p> Type Description <code>sessionmaker</code> <p>A SQLAlchemy <code>Session</code> pool for database connections.</p> Source code in <code>src/auto_xkcd/core/database/methods.py</code> <pre><code>def get_session_pool(engine: sa.Engine = None) -&gt; so.sessionmaker[so.Session]:\n    \"\"\"Return a SQLAlchemy session pool.\n\n    Params:\n        engine (sqlalchemy.Engine): A SQLAlchemy `Engine` to use for database connections.\n\n    Returns:\n        (sqlalchemy.orm.sessionmaker): A SQLAlchemy `Session` pool for database connections.\n\n    \"\"\"\n    assert engine is not None, ValueError(\"engine cannot be None\")\n    assert isinstance(engine, sa.Engine), TypeError(\n        f\"engine must be of type sqlalchemy.Engine. Got type: ({type(engine)})\"\n    )\n\n    session_pool: so.sessionmaker[so.Session] = so.sessionmaker(bind=engine)\n\n    return session_pool\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/annotated/__init__/","title":"annotated","text":"<p>Annotated columns for SQLAlchemy.</p>"},{"location":"reference/auto_xkcd/core/database/annotated/annotated_columns/","title":"annotated_columns","text":"<p>Define <code>Annotated</code> columns for SQLAlchemy models.</p> <p>Examples:</p> <ul> <li><code>INT_PK</code>: An auto-incrementing, primary key integer value.</li> <li><code>STR_10</code>: A <code>VARCHAR(10)</code> column.</li> <li><code>STR_255</code>: A <code>VARCHAR(255)</code> column.</li> </ul>"},{"location":"reference/auto_xkcd/core/database/mixins/__init__/","title":"mixins","text":"<p>SQLAlchemy table mixin classes.</p>"},{"location":"reference/auto_xkcd/core/database/mixins/classes/","title":"classes","text":""},{"location":"reference/auto_xkcd/core/database/mixins/classes/#auto_xkcd.core.database.mixins.classes.TableNameMixin","title":"<code>TableNameMixin</code>","text":"<p>Mixing to automatically name tables based on class name.</p> <p>Generates a <code>__tablename__</code> for classes inheriting from this mixin.</p> Source code in <code>src/auto_xkcd/core/database/mixins/classes.py</code> <pre><code>class TableNameMixin:\n    \"\"\"Mixing to automatically name tables based on class name.\n\n    Generates a `__tablename__` for classes inheriting from this mixin.\n    \"\"\"\n\n    @so.declared_attr.directive\n    def __tablename__(cls) -&gt; str:\n        return cls.__name__.lower() + \"s\"\n</code></pre>"},{"location":"reference/auto_xkcd/core/database/mixins/classes/#auto_xkcd.core.database.mixins.classes.TimestampMixin","title":"<code>TimestampMixin</code>","text":"<p>Add a created_at &amp; updated_at column to records.</p> <p>Add to class declaration to automatically create these columns on records.</p> <p>Usage:</p> TimestampMixin SQLAlchemy table class<pre><code>class Record(Base, TimestampMixin):\n    __tablename__ = ...\n\n    ...\n</code></pre> Source code in <code>src/auto_xkcd/core/database/mixins/classes.py</code> <pre><code>class TimestampMixin:\n    \"\"\"Add a created_at &amp; updated_at column to records.\n\n    Add to class declaration to automatically create these columns on\n    records.\n\n    Usage:\n\n    ```py title=\"TimestampMixin SQLAlchemy table class\" linenums=\"1\"\n    class Record(Base, TimestampMixin):\n        __tablename__ = ...\n\n        ...\n    ```\n    \"\"\"\n\n    created_at: so.Mapped[pendulum.DateTime] = so.mapped_column(\n        sa.TIMESTAMP, server_default=sa.func.now()\n    )\n    updated_at: so.Mapped[pendulum.DateTime] = so.mapped_column(\n        sa.TIMESTAMP, server_default=sa.func.now(), onupdate=sa.func.now()\n    )\n</code></pre>"},{"location":"reference/auto_xkcd/core/exc/__init__/","title":"exc","text":"<p>User-defined exceptions.</p>"},{"location":"reference/auto_xkcd/core/exc/custom/__init__/","title":"custom","text":""},{"location":"reference/auto_xkcd/core/request_client/__init__/","title":"request_client","text":"<p>Lower-level methods &amp; context managers to control an HTTPX client.</p>"},{"location":"reference/auto_xkcd/core/request_client/methods/","title":"methods","text":"<p>Methods to handle generic HTTPX data.</p>"},{"location":"reference/auto_xkcd/core/request_client/methods/#auto_xkcd.core.request_client.methods.build_request","title":"<code>build_request(method='GET', url=None, headers={'Content-Type': 'application/json'}, params=None, data=None)</code>","text":"<p>Assemble an httpx.Request instance from inputs.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The request method type, i.e. \"GET\", \"POST\", \"PUT\", \"DELETE\".</p> <code>'GET'</code> <code>url</code> <code>str</code> <p>The URL to request.</p> <code>None</code> <code>headers</code> <code>dict | None</code> <p>Optional request headers dict.</p> <code>{'Content-Type': 'application/json'}</code> <code>params</code> <code>dict | None</code> <p>Optional request params dict.</p> <code>None</code> <code>data</code> <code>dict | str | None</code> <p>Optional request data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Request</code> <p>An initialized <code>httpx.Request</code> object.</p> Source code in <code>src/auto_xkcd/core/request_client/methods.py</code> <pre><code>def build_request(\n    method: str = \"GET\",\n    url: str = None,\n    headers: dict | None = {\"Content-Type\": \"application/json\"},\n    params: dict | None = None,\n    data: t.Union[dict, str] | None = None,\n) -&gt; httpx.Request:\n    \"\"\"Assemble an httpx.Request instance from inputs.\n\n    Params:\n        method (str): The request method type, i.e. \"GET\", \"POST\", \"PUT\", \"DELETE\".\n        url (str): The URL to request.\n        headers (dict|None): Optional request headers dict.\n        params (dict|None): Optional request params dict.\n        data (dict|str|None): Optional request data.\n\n    Returns:\n        (httpx.Request): An initialized `httpx.Request` object.\n\n    \"\"\"\n    assert method, ValueError(\"Missing a request method\")\n    assert isinstance(method, str), TypeError(\n        f\"method must be of type str. Got type: ({type(method)})\"\n    )\n    method = method.upper()\n\n    assert url, ValueError(\"Missing a request URL\")\n    assert isinstance(url, str), TypeError(\n        f\"url must be a string. Got type: ({type(url)})\"\n    )\n\n    if headers:\n        assert isinstance(headers, dict), TypeError(\n            f\"headers should be a dict. Got type: ({type(headers)})\"\n        )\n    if params:\n        assert isinstance(params, dict), TypeError(\n            f\"params should be a dict. Got type: ({type(params)})\"\n        )\n    if data:\n        assert isinstance(data, dict) or isinstance(data, str), TypeError(\n            f\"data should be a Python dict or JSON string. Got type: ({type(data)})\"\n        )\n\n        if isinstance(data, dict):\n            _data: str = json.dumps(data)\n            data = _data\n\n    try:\n        req: httpx.Request = httpx.Request(\n            method=method, url=url, headers=headers, params=params, data=data\n        )\n\n        return req\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception building {method} request to URL: {url}. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/methods/#auto_xkcd.core.request_client.methods.save_bytes","title":"<code>save_bytes(_bytes=None, output_dir=None, output_filename=None)</code>","text":"<p>Save bytestring to a file.</p> <p>Parameters:</p> Name Type Description Default <code>_bytes</code> <code>bytes</code> <p>A bytestring to save to a file.</p> <code>None</code> <code>output_dir</code> <code>str | Path</code> <p>Directory where bytes file will be saved.</p> <code>None</code> <code>output_filename</code> <code>str</code> <p>Name of the file to be saved at <code>output_dir/</code>output_filename`.</p> <code>None</code> Source code in <code>src/auto_xkcd/core/request_client/methods.py</code> <pre><code>def save_bytes(\n    _bytes: bytes = None,\n    output_dir: t.Union[str, Path] = None,\n    output_filename: str = None,\n) -&gt; bool:\n    \"\"\"Save bytestring to a file.\n\n    Params:\n        _bytes (bytes): A bytestring to save to a file.\n        output_dir (str|Path): Directory where bytes file will be saved.\n        output_filename (str): Name of the file to be saved at `output_dir/`output_filename`.\n\n    \"\"\"\n    assert output_dir, ValueError(\"Missing output directory path\")\n    assert isinstance(output_dir, str) or isinstance(output_dir, Path), TypeError(\n        f\"output_dir must be a str or Path. Got type: ({type(output_dir)})\"\n    )\n    if isinstance(output_dir, Path):\n        if \"~\" in f\"{output_dir}\":\n            _dir: Path = output_dir.expanduser()\n            output_dir = _dir\n    elif isinstance(output_dir, str):\n        if \"~\" in output_dir:\n            output_dir: Path = Path(output_dir).expanduser()\n        else:\n            output_dir: Path = Path(output_dir)\n\n    assert output_filename, ValueError(\"Missing output filename\")\n    assert isinstance(output_filename, str), TypeError(\n        f\"output_filename must be a string. Got type: ({type(output_filename)})\"\n    )\n\n    assert _bytes, ValueError(\"Missing bytestring to save.\")\n    assert isinstance(_bytes, bytes), TypeError(\n        f\"_bytes must be of type bytes. Got type: ({type(_bytes)})\"\n    )\n\n    ## Concatenate output_dir and output_filename into a Path object\n    output_path: Path = Path(f\"{output_dir}/{output_filename}\")\n    if not output_path.parent.exists():\n        ## Create output_dir if it does not exist.\n        log.warning(\n            f\"Parent directory '{output_path.parent}' does not exist. Creating.\"\n        )\n        try:\n            output_path.parent.mkdir(parents=True, exist_ok=True)\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception creating directory '{output_path.parent}'. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n\n    ## Save img bytes\n    try:\n        with open(output_path, \"wb\") as f:\n            f.write(_bytes)\n            log.success(f\"Image saved to path '{output_path}'\")\n\n        return True\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception saving image to path '{output_path}'. Details: {exc}\"\n        )\n        log.error(msg)\n\n        # raise msg\n\n        return False\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/context_managers/__init__/","title":"context_managers","text":"<p>Context managers to control HTTPX clients/transports.</p>"},{"location":"reference/auto_xkcd/core/request_client/context_managers/_client/","title":"_client","text":""},{"location":"reference/auto_xkcd/core/request_client/context_managers/_client/#auto_xkcd.core.request_client.context_managers._client.HTTPXController","title":"<code>HTTPXController</code>","text":"<p>             Bases: <code>AbstractContextManager</code></p> <p>Handler for HTTPX client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>Scope the httpx client to a URL.</p> <code>None</code> <code>base_url</code> <code>str | None</code> <p>A base URL will be prefixed to each request. I.e. if <code>base_url=\"https://example.com\", and you want to request \"https://example.com/endpoint,\" you can set the base URL and then request</code>/endpoint`.</p> <code>None</code> <code>proxy</code> <code>str | None</code> <p> <code>None</code> <code>proxies</code> <code>str | None</code> <p> <code>None</code> <code>mounts</code> <code>dict[str, HTTPTransport] | None</code> <p>A dict of <code>httpx.HTTPTransport</code> objects.</p> <code>{}</code> <code>cookies</code> <code>dict[str, Any]</code> <p> <code>{}</code> <code>auth</code> <code>Auth | None</code> <p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Optional request headers to apply to all requests handled by controller instance.</p> <code>{}</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Optional request params to apply to all requests handled by controller instance.</p> <code>{}</code> <code>follow_redirects</code> <code>bool</code> <p>[Default: False] Follow HTTP 302 redirects.</p> <code>False</code> <code>max_redirects</code> <code>int | None</code> <p>[Default: 20] Maximum number of HTTP 302 redirects to follow.</p> <code>20</code> <code>retries</code> <code>int | None</code> <p>Number of times to retry on request failure.</p> <code>None</code> <code>timeout</code> <code>int | float | None</code> <p>Timeout (in seconds) until client gives up on request.</p> <code>60</code> <code>limits</code> <code>Limits | None</code> <p> <code>None</code> <code>transport</code> <code>HTTPTransport | CacheTransport | None</code> <p>A transport to pass to class's <code>httpx.Client</code> object.</p> <code>None</code> <code>default_encoding</code> <code>str</code> <p>[Default: utf-8] Set default encoding for all requests.</p> <code>autodetect_charset</code> Source code in <code>src/auto_xkcd/core/request_client/context_managers/_client.py</code> <pre><code>class HTTPXController(AbstractContextManager):\n    \"\"\"Handler for HTTPX client.\n\n    Params:\n        url (str|None): Scope the httpx client to a URL.\n        base_url (str|None): A base URL will be prefixed to each request. I.e. if `base_url=\"https://example.com\",\n            and you want to request \"https://example.com/endpoint,\" you can set the base URL and then request `/endpoint`.\n        proxy (str|None): &lt;Not yet documented&gt;\n        proxies (str|None): &lt;Not yet documented&gt;\n        mounts (dict[str, httpx.HTTPTransport]|None): A dict of `httpx.HTTPTransport` objects.\n        cookies (dict[str, Any]): &lt;Not yet documented&gt;\n        auth (httpx.Auth | None): &lt;Not yet documented&gt;\n        headers (dict[str, str]|None): Optional request headers to apply to all requests handled by controller instance.\n        params (dict[str, Any]|None): Optional request params to apply to all requests handled by controller instance.\n        follow_redirects (bool): [Default: False] Follow HTTP 302 redirects.\n        max_redirects (int|None): [Default: 20] Maximum number of HTTP 302 redirects to follow.\n        retries (int|None): Number of times to retry on request failure.\n        timeout (int|float|None): Timeout (in seconds) until client gives up on request.\n        limits (httpx.Limits | None): &lt;Not yet documented&gt;\n        transport (httpx.HTTPTransport|hishel.CacheTransport|None): A transport to pass to class's `httpx.Client` object.\n        default_encoding (str): [Default: utf-8] Set default encoding for all requests.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        url: str | None = None,\n        base_url: str | None = None,\n        proxy: str | None = None,\n        proxies: dict[str, str] | None = None,\n        mounts: dict[str, httpx.HTTPTransport] | None = {},\n        cookies: dict[str, t.Any] | None = {},\n        auth: httpx.Auth | None = None,\n        headers: dict[str, str] | None = {},\n        params: dict[str, t.Any] | None = {},\n        follow_redirects: bool = False,\n        max_redirects: int | None = 20,\n        retries: int | None = None,\n        timeout: t.Union[int, float] | None = 60,\n        limits: httpx.Limits | None = None,\n        transport: t.Union[httpx.HTTPTransport, hishel.CacheTransport] | None = None,\n        default_encoding: str = autodetect_charset,\n    ) -&gt; None:\n        self.url: httpx.URL | None = httpx.URL(url) if url else None\n        self.base_url: httpx.URL | None = httpx.URL(base_url) if base_url else None\n        self.proxy: str | None = proxy\n        self.proxies: dict[str, str] | None = proxies\n        self.mounts: dict[str, httpx.HTTPTransport] | None = mounts\n        self.auth: httpx.Auth | None = auth\n        self.headers: dict[str, str] | None = headers\n        self.cookies: dict[str, t.Any] | None = cookies\n        self.params: dict[str, str] | None = params\n        self.follow_redirects: bool = follow_redirects\n        self.max_redirects: int | None = max_redirects\n        self.retries: int | None = retries\n        self.timeout: t.Union[int, float] | None = timeout\n        self.limits: httpx.Limits | None = limits\n        self.transport: t.Union[httpx.HTTPTransport, hishel.CacheTransport] | None = (\n            transport\n        )\n        self.default_encoding: str = default_encoding\n\n        ## Placeholder for initialized httpx.Client\n        self.client: httpx.Client | None = None\n\n    def __enter__(self) -&gt; t.Self:\n        \"\"\"Execute when handler is called in a `with` statement.\n\n        Description:\n            Creates an `httpx.Client` object, using class parameters as options.\n        \"\"\"\n        try:\n            _client: httpx.Client = httpx.Client(\n                auth=self.auth,\n                params=self.params,\n                headers=self.headers,\n                cookies=self.cookies,\n                proxy=self.proxy,\n                proxies=self.proxies,\n                mounts=self.mounts,\n                timeout=self.timeout,\n                follow_redirects=self.follow_redirects,\n                max_redirects=self.max_redirects,\n                # base_url=self.base_url,\n                transport=self.transport,\n                default_encoding=self.default_encoding,\n            )\n\n            ## If base_url is None, an exception occurs. Set self.base_url\n            #  only if base_url is not None.\n            if self.base_url:\n                _client.base_url = self.base_url\n\n            self.client = _client\n\n            return self\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception initializing httpx Client. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise exc\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Execute  when `with` statement ends.\n\n        Description:\n            Show any exceptions/tracebacks. Close `self.client` on exit.\n\n        \"\"\"\n        if exc_type:\n            log.error(f\"({exc_type}): {exc_value}\")\n\n        if traceback:\n            log.trace(traceback)\n\n        ## Close httpx client\n        if self.client:\n            self.client.close()\n\n    def new_request(\n        self,\n        method: str = \"GET\",\n        url: str | httpx.URL = None,\n        files: list | None = None,\n        _json: t.Any | None = None,\n        headers: dict | None = {},\n        cookies: dict | None = None,\n        timeout: int | float | None = None,\n    ) -&gt; httpx.Request:\n        \"\"\"Assemble a new httpx.Request object from parts.\n\n        Params:\n            method (str): [Default: \"GET\"] HTTP method for request.\n            url (str|httpx.URL): URL to send request.\n            files (list|None): List of files to send with request. Only works with certain HTTP methods,\n                list `POST`.\n            json (t.Any | None): JSON to append to request.\n            headers (dict|None): Request headers.\n            cookies (dict): &lt;Not yet documented&gt;\n            timeout (int|float): Timeout (in seconds) before cancelling request.\n\n        Returns:\n            (httpx.Request): An initialized `httpx.Request` object.\n\n        \"\"\"\n        assert method, ValueError(\"Missing a request method\")\n        assert isinstance(method, str), TypeError(\n            f\"method should be a string. Got type: ({type(method)})\"\n        )\n\n        ## Ensure method is uppercase, i.e. 'get' -&gt; 'GET'\n        method: str = method.upper()\n\n        assert url, ValueError(\"Missing a URL\")\n        assert isinstance(url, str) or isinstance(url, httpx.URL), TypeError(\n            f\"URL must be a string or httpx.URL. Got type: ({type(url)})\"\n        )\n        if isinstance(url, str):\n            ## Convert URL from string into httpx.URL object\n            url: httpx.URL = httpx.URL(url=url)\n\n        if timeout:\n            assert (\n                isinstance(timeout, int) or isinstance(timeout, float)\n            ) and timeout &gt; 0, TypeError(\n                f\"timeout must be a non-zero positive int or float. Got type: ({type(timeout)})\"\n            )\n\n        ## Build httpx.Request object\n        try:\n            _req: httpx.Request = self.client.build_request(\n                method=method,\n                url=url,\n                files=files,\n                json=_json,\n                headers=headers,\n                cookies=cookies,\n                timeout=timeout,\n            )\n\n            return _req\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception creaeting httpx.Request object. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n\n    def send_request(\n        self,\n        request: httpx.Request = None,\n        stream: bool = False,\n        auth: httpx.Auth = None,\n    ) -&gt; httpx.Response:\n        \"\"\"Send httpx.Request using self.Client (and optional cache transport).\n\n        Params:\n            request (httpx.Request): An initialized `httpx.Request` object.\n            stream (bool): When `True`, response bytes will be streamed. This can be useful for large file downloads.\n            auth (httpx.Auth): &lt;Not yet documented&gt;\n\n        Returns:\n            (httpx.Response): An `httpx.Response` from the request.\n\n        \"\"\"\n        assert request, ValueError(\"Missing an httpx.Request object\")\n        assert isinstance(request, httpx.Request), TypeError(\n            f\"Expected request to be an httpx.Request object. Got type: ({type(request)})\"\n        )\n\n        ## Send request using class's httpx.Client\n        try:\n            res: httpx.Response = self.client.send(\n                request=request,\n                stream=stream,\n                auth=auth,\n                follow_redirects=self.follow_redirects,\n            )\n            log.debug(\n                f\"URL: {request.url}, Response: [{res.status_code}: {res.reason_phrase}]\"\n            )\n\n            return res\n\n        except httpx.ConnectError as conn_err:\n            ## Error connecting to remote\n            msg = Exception(\n                f\"ConnectError while requesting URL {request.url}. Details: {conn_err}\"\n            )\n            log.error(msg)\n\n            return\n        except Exception as exc:\n            msg = Exception(f\"Unhandled exception sending request. Details: {exc}\")\n            log.error(msg)\n\n            raise msg\n\n    def decode_res_content(self, res: httpx.Response = None) -&gt; dict:\n        \"\"\"Use multiple methods to attempt to decode an `httpx.Response.content` bytestring.\n\n        Params:\n            res (httpx.Response): An `httpx.Response` object, with `.content` to be decoded.\n\n        Returns:\n            (dict): A `dict` from the `httpx.Response`'s `.content` param.\n\n        \"\"\"\n        assert res, ValueError(\"Missing httpx Response object\")\n        assert isinstance(res, httpx.Response), TypeError(\n            f\"res must be of type httpx.Response. Got type: ({type(res)})\"\n        )\n\n        _content: bytes = res.content\n        assert _content, ValueError(\"Response content is empty\")\n        assert isinstance(_content, bytes), TypeError(\n            f\"Expected response.content to be a bytestring. Got type: ({type(_content)})\"\n        )\n\n        ## Get content's encoding, or default to 'utf-8'\n        try:\n            decode_charset: str = autodetect_charset(content=_content)\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception detecting response content's encoding. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n            log.warning(f\"Defaulting to 'utf-8'\")\n\n            decode_charset: str = \"utf-8\"\n\n        ## Decode content\n        try:\n            _decode: str = res.content.decode(decode_charset)\n\n        except Exception as exc:\n            ## Decoding failed, retry with different encodings\n            msg = Exception(\n                f\"[Attempt 1/2] Unhandled exception decoding response content. Details: {exc}\"\n            )\n            log.warning(msg)\n\n            if not res.encoding == \"utf-8\":\n                ## Try decoding again, using response's .encoding param\n                log.warning(\n                    f\"Retrying response content decode with encoding '{res.encoding}'\"\n                )\n                try:\n                    _decode = res.content.decode(res.encoding)\n                except Exception as exc:\n                    inner_msg = Exception(\n                        f\"[Attempt 2/2] Unhandled exception decoding response content. Details: {exc}\"\n                    )\n                    log.error(inner_msg)\n\n                    raise inner_msg\n\n            else:\n                ## Decoding with utf-8 failed, attempt with ISO-8859-1\n                #  https://en.wikipedia.org/wiki/ISO/IEC_8859-1\n                log.warning(\n                    f\"Detected UTF-8 encoding, but decoding as UTF-8 failed. Retrying with encoding ISO-8859-1.\"\n                )\n                try:\n                    _decode = res.content.decode(\"ISO-8859-1\")\n                except Exception as exc:\n                    msg = Exception(\n                        f\"Failure attempting to decode content as UTF-8 and ISO-8859-1. Details: {exc}\"\n                    )\n\n                    raise msg\n\n        ## Load decoded content into dict\n        try:\n            _json: dict = json.loads(_decode)\n\n            return _json\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception loading decoded response content to dict. Details: {exc}\"\n            )\n\n            raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/context_managers/_client/#auto_xkcd.core.request_client.context_managers._client.HTTPXController.__enter__","title":"<code>__enter__()</code>","text":"<p>Execute when handler is called in a <code>with</code> statement.</p> Description <p>Creates an <code>httpx.Client</code> object, using class parameters as options.</p> Source code in <code>src/auto_xkcd/core/request_client/context_managers/_client.py</code> <pre><code>def __enter__(self) -&gt; t.Self:\n    \"\"\"Execute when handler is called in a `with` statement.\n\n    Description:\n        Creates an `httpx.Client` object, using class parameters as options.\n    \"\"\"\n    try:\n        _client: httpx.Client = httpx.Client(\n            auth=self.auth,\n            params=self.params,\n            headers=self.headers,\n            cookies=self.cookies,\n            proxy=self.proxy,\n            proxies=self.proxies,\n            mounts=self.mounts,\n            timeout=self.timeout,\n            follow_redirects=self.follow_redirects,\n            max_redirects=self.max_redirects,\n            # base_url=self.base_url,\n            transport=self.transport,\n            default_encoding=self.default_encoding,\n        )\n\n        ## If base_url is None, an exception occurs. Set self.base_url\n        #  only if base_url is not None.\n        if self.base_url:\n            _client.base_url = self.base_url\n\n        self.client = _client\n\n        return self\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception initializing httpx Client. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/context_managers/_client/#auto_xkcd.core.request_client.context_managers._client.HTTPXController.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Execute  when <code>with</code> statement ends.</p> Description <p>Show any exceptions/tracebacks. Close <code>self.client</code> on exit.</p> Source code in <code>src/auto_xkcd/core/request_client/context_managers/_client.py</code> <pre><code>def __exit__(self, exc_type, exc_value, traceback):\n    \"\"\"Execute  when `with` statement ends.\n\n    Description:\n        Show any exceptions/tracebacks. Close `self.client` on exit.\n\n    \"\"\"\n    if exc_type:\n        log.error(f\"({exc_type}): {exc_value}\")\n\n    if traceback:\n        log.trace(traceback)\n\n    ## Close httpx client\n    if self.client:\n        self.client.close()\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/context_managers/_client/#auto_xkcd.core.request_client.context_managers._client.HTTPXController.decode_res_content","title":"<code>decode_res_content(res=None)</code>","text":"<p>Use multiple methods to attempt to decode an <code>httpx.Response.content</code> bytestring.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>Response</code> <p>An <code>httpx.Response</code> object, with <code>.content</code> to be decoded.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A <code>dict</code> from the <code>httpx.Response</code>'s <code>.content</code> param.</p> Source code in <code>src/auto_xkcd/core/request_client/context_managers/_client.py</code> <pre><code>def decode_res_content(self, res: httpx.Response = None) -&gt; dict:\n    \"\"\"Use multiple methods to attempt to decode an `httpx.Response.content` bytestring.\n\n    Params:\n        res (httpx.Response): An `httpx.Response` object, with `.content` to be decoded.\n\n    Returns:\n        (dict): A `dict` from the `httpx.Response`'s `.content` param.\n\n    \"\"\"\n    assert res, ValueError(\"Missing httpx Response object\")\n    assert isinstance(res, httpx.Response), TypeError(\n        f\"res must be of type httpx.Response. Got type: ({type(res)})\"\n    )\n\n    _content: bytes = res.content\n    assert _content, ValueError(\"Response content is empty\")\n    assert isinstance(_content, bytes), TypeError(\n        f\"Expected response.content to be a bytestring. Got type: ({type(_content)})\"\n    )\n\n    ## Get content's encoding, or default to 'utf-8'\n    try:\n        decode_charset: str = autodetect_charset(content=_content)\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception detecting response content's encoding. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n        log.warning(f\"Defaulting to 'utf-8'\")\n\n        decode_charset: str = \"utf-8\"\n\n    ## Decode content\n    try:\n        _decode: str = res.content.decode(decode_charset)\n\n    except Exception as exc:\n        ## Decoding failed, retry with different encodings\n        msg = Exception(\n            f\"[Attempt 1/2] Unhandled exception decoding response content. Details: {exc}\"\n        )\n        log.warning(msg)\n\n        if not res.encoding == \"utf-8\":\n            ## Try decoding again, using response's .encoding param\n            log.warning(\n                f\"Retrying response content decode with encoding '{res.encoding}'\"\n            )\n            try:\n                _decode = res.content.decode(res.encoding)\n            except Exception as exc:\n                inner_msg = Exception(\n                    f\"[Attempt 2/2] Unhandled exception decoding response content. Details: {exc}\"\n                )\n                log.error(inner_msg)\n\n                raise inner_msg\n\n        else:\n            ## Decoding with utf-8 failed, attempt with ISO-8859-1\n            #  https://en.wikipedia.org/wiki/ISO/IEC_8859-1\n            log.warning(\n                f\"Detected UTF-8 encoding, but decoding as UTF-8 failed. Retrying with encoding ISO-8859-1.\"\n            )\n            try:\n                _decode = res.content.decode(\"ISO-8859-1\")\n            except Exception as exc:\n                msg = Exception(\n                    f\"Failure attempting to decode content as UTF-8 and ISO-8859-1. Details: {exc}\"\n                )\n\n                raise msg\n\n    ## Load decoded content into dict\n    try:\n        _json: dict = json.loads(_decode)\n\n        return _json\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception loading decoded response content to dict. Details: {exc}\"\n        )\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/context_managers/_client/#auto_xkcd.core.request_client.context_managers._client.HTTPXController.new_request","title":"<code>new_request(method='GET', url=None, files=None, _json=None, headers={}, cookies=None, timeout=None)</code>","text":"<p>Assemble a new httpx.Request object from parts.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>[Default: \"GET\"] HTTP method for request.</p> <code>'GET'</code> <code>url</code> <code>str | URL</code> <p>URL to send request.</p> <code>None</code> <code>files</code> <code>list | None</code> <p>List of files to send with request. Only works with certain HTTP methods, list <code>POST</code>.</p> <code>None</code> <code>json</code> <code>Any | None</code> <p>JSON to append to request.</p> required <code>headers</code> <code>dict | None</code> <p>Request headers.</p> <code>{}</code> <code>cookies</code> <code>dict</code> <p> <code>None</code> <code>timeout</code> <code>int | float</code> <p>Timeout (in seconds) before cancelling request.</p> <code>None</code> <p>Returns:</p> Type Description <code>Request</code> <p>An initialized <code>httpx.Request</code> object.</p> Source code in <code>src/auto_xkcd/core/request_client/context_managers/_client.py</code> <pre><code>def new_request(\n    self,\n    method: str = \"GET\",\n    url: str | httpx.URL = None,\n    files: list | None = None,\n    _json: t.Any | None = None,\n    headers: dict | None = {},\n    cookies: dict | None = None,\n    timeout: int | float | None = None,\n) -&gt; httpx.Request:\n    \"\"\"Assemble a new httpx.Request object from parts.\n\n    Params:\n        method (str): [Default: \"GET\"] HTTP method for request.\n        url (str|httpx.URL): URL to send request.\n        files (list|None): List of files to send with request. Only works with certain HTTP methods,\n            list `POST`.\n        json (t.Any | None): JSON to append to request.\n        headers (dict|None): Request headers.\n        cookies (dict): &lt;Not yet documented&gt;\n        timeout (int|float): Timeout (in seconds) before cancelling request.\n\n    Returns:\n        (httpx.Request): An initialized `httpx.Request` object.\n\n    \"\"\"\n    assert method, ValueError(\"Missing a request method\")\n    assert isinstance(method, str), TypeError(\n        f\"method should be a string. Got type: ({type(method)})\"\n    )\n\n    ## Ensure method is uppercase, i.e. 'get' -&gt; 'GET'\n    method: str = method.upper()\n\n    assert url, ValueError(\"Missing a URL\")\n    assert isinstance(url, str) or isinstance(url, httpx.URL), TypeError(\n        f\"URL must be a string or httpx.URL. Got type: ({type(url)})\"\n    )\n    if isinstance(url, str):\n        ## Convert URL from string into httpx.URL object\n        url: httpx.URL = httpx.URL(url=url)\n\n    if timeout:\n        assert (\n            isinstance(timeout, int) or isinstance(timeout, float)\n        ) and timeout &gt; 0, TypeError(\n            f\"timeout must be a non-zero positive int or float. Got type: ({type(timeout)})\"\n        )\n\n    ## Build httpx.Request object\n    try:\n        _req: httpx.Request = self.client.build_request(\n            method=method,\n            url=url,\n            files=files,\n            json=_json,\n            headers=headers,\n            cookies=cookies,\n            timeout=timeout,\n        )\n\n        return _req\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception creaeting httpx.Request object. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/context_managers/_client/#auto_xkcd.core.request_client.context_managers._client.HTTPXController.send_request","title":"<code>send_request(request=None, stream=False, auth=None)</code>","text":"<p>Send httpx.Request using self.Client (and optional cache transport).</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>An initialized <code>httpx.Request</code> object.</p> <code>None</code> <code>stream</code> <code>bool</code> <p>When <code>True</code>, response bytes will be streamed. This can be useful for large file downloads.</p> <code>False</code> <code>auth</code> <code>Auth</code> <p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>An <code>httpx.Response</code> from the request.</p> Source code in <code>src/auto_xkcd/core/request_client/context_managers/_client.py</code> <pre><code>def send_request(\n    self,\n    request: httpx.Request = None,\n    stream: bool = False,\n    auth: httpx.Auth = None,\n) -&gt; httpx.Response:\n    \"\"\"Send httpx.Request using self.Client (and optional cache transport).\n\n    Params:\n        request (httpx.Request): An initialized `httpx.Request` object.\n        stream (bool): When `True`, response bytes will be streamed. This can be useful for large file downloads.\n        auth (httpx.Auth): &lt;Not yet documented&gt;\n\n    Returns:\n        (httpx.Response): An `httpx.Response` from the request.\n\n    \"\"\"\n    assert request, ValueError(\"Missing an httpx.Request object\")\n    assert isinstance(request, httpx.Request), TypeError(\n        f\"Expected request to be an httpx.Request object. Got type: ({type(request)})\"\n    )\n\n    ## Send request using class's httpx.Client\n    try:\n        res: httpx.Response = self.client.send(\n            request=request,\n            stream=stream,\n            auth=auth,\n            follow_redirects=self.follow_redirects,\n        )\n        log.debug(\n            f\"URL: {request.url}, Response: [{res.status_code}: {res.reason_phrase}]\"\n        )\n\n        return res\n\n    except httpx.ConnectError as conn_err:\n        ## Error connecting to remote\n        msg = Exception(\n            f\"ConnectError while requesting URL {request.url}. Details: {conn_err}\"\n        )\n        log.error(msg)\n\n        return\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception sending request. Details: {exc}\")\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/context_managers/_client/#auto_xkcd.core.request_client.context_managers._client.autodetect_charset","title":"<code>autodetect_charset(content=None)</code>","text":"<p>Attempt to automatically detect encoding from input bytestring.</p> Source code in <code>src/auto_xkcd/core/request_client/context_managers/_client.py</code> <pre><code>def autodetect_charset(content: bytes = None):\n    \"\"\"Attempt to automatically detect encoding from input bytestring.\"\"\"\n    try:\n        ## Detect encoding from bytes\n        _encoding: str | None = chardet.detect(byte_str=content).get(\"encoding\")\n\n        if not _encoding:\n            ## Default to utf-8\n            _encoding = \"utf-8\"\n\n        return _encoding\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception auto-detecting character set for input bytestring. Details: {exc}\"\n        )\n        log.error(msg)\n        log.warning(\"Defaulting to utf-8\")\n\n        return \"utf-8\"\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/encoders/__init__/","title":"encoders","text":"<p>Encoding/decoding helpers.</p>"},{"location":"reference/auto_xkcd/core/request_client/encoders/json_encoders/__init__/","title":"json_encoders","text":"<p>JSON encoder/decoder helpers.</p>"},{"location":"reference/auto_xkcd/core/request_client/encoders/json_encoders/_encoders/","title":"_encoders","text":""},{"location":"reference/auto_xkcd/core/request_client/encoders/json_encoders/_encoders/#auto_xkcd.core.request_client.encoders.json_encoders._encoders.DateTimeEncoder","title":"<code>DateTimeEncoder</code>","text":"<p>             Bases: <code>JSONEncoder</code></p> <p>Handle encoding a <code>datetime.datetime</code> or <code>pendulum.DateTime</code> as an ISO-formatted string.</p> Source code in <code>src/auto_xkcd/core/request_client/encoders/json_encoders/_encoders.py</code> <pre><code>class DateTimeEncoder(json.JSONEncoder):\n    \"\"\"Handle encoding a `datetime.datetime` or `pendulum.DateTime` as an ISO-formatted string.\"\"\"\n\n    def default(self, o) -&gt; str | json.Any:\n        if isinstance(o, datetime):\n            return o.isoformat()\n        elif isinstance(o, pendulum.DateTime):\n            return o.isoformat()\n\n        return json.JSONEncoder.default(self=self, o=o)\n</code></pre>"},{"location":"reference/auto_xkcd/core/request_client/transports/__init__/","title":"transports","text":"<p>Pre-defined transports for an HTTPX client.</p>"},{"location":"reference/auto_xkcd/core/request_client/transports/_transports/","title":"_transports","text":""},{"location":"reference/auto_xkcd/core/request_client/transports/_transports/#auto_xkcd.core.request_client.transports._transports.get_cache_transport","title":"<code>get_cache_transport(cache_dir='.cache/hishel', ttl=None, verify=True, retries=0, cert=None)</code>","text":"<p>Return an initialized hishel.CacheTransport.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>str</code> <p>[default: .cache/hishel] Directory where cache files will be stored.</p> <code>'.cache/hishel'</code> <code>ttl</code> <code>int | None</code> <p>[default: None] Limit ttl on requests sent with this transport.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>[default: True] Verify SSL certificates on requests sent with this transport.</p> <code>True</code> <code>retriest</code> <code>int</code> <p>[default: 0] Number of times to retry requests sent with this transport.</p> required <code>cert</code> <code>valid HTTPX Cert</code> <p>An optional SSL certificate to send with requests.</p> <code>None</code> Source code in <code>src/auto_xkcd/core/request_client/transports/_transports.py</code> <pre><code>def get_cache_transport(\n    cache_dir: str = \".cache/hishel\",\n    ttl: int | None = None,\n    verify: bool = True,\n    retries: int = 0,\n    cert: t.Union[\n        str, tuple[str, str | None], tuple[str, str | None, str | None]\n    ] = None,\n) -&gt; hishel.CacheTransport:\n    \"\"\"Return an initialized hishel.CacheTransport.\n\n    Params:\n        cache_dir (str): [default: .cache/hishel] Directory where cache files will be stored.\n        ttl (int|None): [default: None] Limit ttl on requests sent with this transport.\n        verify (bool): [default: True] Verify SSL certificates on requests sent with this transport.\n        retriest (int): [default: 0] Number of times to retry requests sent with this transport.\n        cert (valid HTTPX Cert): An optional SSL certificate to send with requests.\n\n    \"\"\"\n    # Create a cache instance with hishel\n    cache_storage = hishel.FileStorage(base_path=cache_dir, ttl=ttl)\n    cache_transport = httpx.HTTPTransport(verify=verify, cert=cert, retries=retries)\n\n    try:\n        # Create an HTTP cache transport\n        cache_transport = hishel.CacheTransport(\n            transport=cache_transport, storage=cache_storage\n        )\n\n        return cache_transport\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception returning cache transport. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/domain/__init__/","title":"domain","text":"<p>Classes, models, &amp; repositories for the app.</p>"},{"location":"reference/auto_xkcd/domain/pipelines/__init__/","title":"pipelines","text":"<p>Pipelines string packages &amp; modules together into chains of repeatable actions.</p> <p>Pipelines can retrieve, process, and return results in a repeatable/factory-like way.</p>"},{"location":"reference/auto_xkcd/domain/pipelines/schemas/","title":"schemas","text":""},{"location":"reference/auto_xkcd/domain/pipelines/schemas/#auto_xkcd.domain.pipelines.schemas.PipelineConfig","title":"<code>PipelineConfig</code>","text":"<p>             Bases: <code>PipelineConfigBase</code></p> <p>Store configuration for a pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the pipeline</p> required <code>loop_settings</code> <code>PipelineeLoopConfig</code> <p>Configurations for looping, if pipeline supports loops.</p> required Source code in <code>src/auto_xkcd/domain/pipelines/schemas.py</code> <pre><code>class PipelineConfig(PipelineConfigBase):\n    \"\"\"Store configuration for a pipeline.\n\n    Params:\n        name (str): Name for the pipeline\n        loop_settings (PipelineeLoopConfig): Configurations for looping, if pipeline supports loops.\n\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/auto_xkcd/domain/pipelines/schemas/#auto_xkcd.domain.pipelines.schemas.PipelineLoopConfig","title":"<code>PipelineLoopConfig</code>","text":"<p>             Bases: <code>PipelineLoopConfigBase</code></p> <p>Configuration for a pipeline's looping functionality.</p> <p>THIS CLASS IS NOT READY FOR USE.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>bool</code> <p>[Default: <code>False</code>] If <code>True</code>, apply loop configurations to the pipeline.</p> required <code>loop_pause</code> <code>int | float</code> <p>Time (in seconds) to wait/pause between loops.</p> required <code>max_loops</code> <code>int | None</code> <p>[Default: None] If set, pipeline will loop numer of times defined.</p> required <code>continue_on_error</code> <code>bool</code> <p>If <code>True</code>, pipeline loop will continue passed errored loops instead of exiting.</p> required Source code in <code>src/auto_xkcd/domain/pipelines/schemas.py</code> <pre><code>class PipelineLoopConfig(PipelineLoopConfigBase):\n    \"\"\"Configuration for a pipeline's looping functionality.\n\n    THIS CLASS IS NOT READY FOR USE.\n\n    Params:\n        loop (bool): [Default: `False`] If `True`, apply loop configurations to the pipeline.\n        loop_pause (int|float): Time (in seconds) to wait/pause between loops.\n        max_loops (int|None): [Default: None] If set, pipeline will loop numer of times defined.\n        continue_on_error (bool): If `True`, pipeline loop will continue passed errored loops instead of exiting.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/__init__/","title":"xkcd","text":"<p>Classes &amp; models for XKCD comic data.</p>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/__init__/","title":"comic","text":""},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/","title":"models","text":"<p>SQLAlchemy table classes for XKCD comics.</p>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDComicModel","title":"<code>XKCDComicModel</code>","text":"<p>             Bases: <code>Base</code></p> <p>Table model for XKCD comics.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>str</code> <p>Published year</p> required <code>month</code> <code>str</code> <p>Published month</p> required <code>day</code> <code>str</code> <p>Published day</p> required <code>comic_num</code> <code>int</code> <p>Comic number</p> required <code>link</code> <code>str | None</code> <p>Link to comic.</p> required <code>title</code> <code>str</code> <p>Comic title.</p> required <code>transcript</code> <code>str | None</code> <p>Comic transcript.</p> required <code>alt_text</code> <code>str</code> <p>Comic alt text.</p> required <code>img_url</code> <code>str</code> <p>Link to comic image.</p> required <code>img</code> <code>bytes</code> <p>Image bytestring.</p> required Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>class XKCDComicModel(Base):\n    \"\"\"Table model for XKCD comics.\n\n    Params:\n        year (str): Published year\n        month (str): Published month\n        day (str): Published day\n        comic_num (int): Comic number\n        link (str|None): Link to comic.\n        title (str): Comic title.\n        transcript (str|None): Comic transcript.\n        alt_text (str): Comic alt text.\n        img_url (str): Link to comic image.\n        img (bytes): Image bytestring.\n\n    \"\"\"\n\n    __tablename__ = \"xkcd_comic\"\n    __table_args__ = (sa.UniqueConstraint(\"comic_num\", name=\"_comic_num_uc\"),)\n\n    comic_id: so.Mapped[INT_PK]\n\n    year: so.Mapped[str] = so.mapped_column(sa.VARCHAR(255))\n    month: so.Mapped[str] = so.mapped_column(sa.VARCHAR(255))\n    day: so.Mapped[str] = so.mapped_column(sa.VARCHAR(255))\n    comic_num: so.Mapped[int] = so.mapped_column(sa.INTEGER)\n    link: so.Mapped[str | None] = so.mapped_column(sa.VARCHAR(255))\n    title: so.Mapped[str] = so.mapped_column(sa.VARCHAR(255))\n    transcript: so.Mapped[str | None] = so.mapped_column(sa.VARCHAR(255))\n    alt_text: so.Mapped[str] = so.mapped_column(__name_pos=sa.VARCHAR(255))\n    img_url: so.Mapped[str] = so.mapped_column(sa.VARCHAR(255))\n    img: so.Mapped[bytes] = so.mapped_column(sa.LargeBinary)\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDComicRepositoryBase","title":"<code>XKCDComicRepositoryBase</code>","text":"<p>Base database repository class for XKCDComic.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>class XKCDComicRepositoryBase(metaclass=abc.ABCMeta):\n    \"\"\"Base database repository class for XKCDComic.\"\"\"\n\n    @abc.abstractmethod\n    def add(self, entity: XKCDComicModel):\n        \"\"\"Add new entity to repository.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def remove(self, entity: XKCDComicModel):\n        \"\"\"Remove existing entity from repository.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def get_by_id(self, comic_id: int) -&gt; XKCDComicModel:\n        \"\"\"Retrieve entity from repository by its ID.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDComicRepositoryBase.add","title":"<code>add(entity)</code>  <code>abstractmethod</code>","text":"<p>Add new entity to repository.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>@abc.abstractmethod\ndef add(self, entity: XKCDComicModel):\n    \"\"\"Add new entity to repository.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDComicRepositoryBase.get_by_id","title":"<code>get_by_id(comic_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve entity from repository by its ID.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>@abc.abstractmethod\ndef get_by_id(self, comic_id: int) -&gt; XKCDComicModel:\n    \"\"\"Retrieve entity from repository by its ID.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDComicRepositoryBase.remove","title":"<code>remove(entity)</code>  <code>abstractmethod</code>","text":"<p>Remove existing entity from repository.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>@abc.abstractmethod\ndef remove(self, entity: XKCDComicModel):\n    \"\"\"Remove existing entity from repository.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDSentComicModel","title":"<code>XKCDSentComicModel</code>","text":"<p>             Bases: <code>Base</code></p> <p>Metadata about comics sent via Telegram.</p> <p>Parameters:</p> Name Type Description Default <code>sent_comic_id</code> <code>INT_PK</code> <p>Primary key for sent comic.</p> required <code>comic_num</code> <code>int</code> <p>Comic's number.</p> required <code>date_sent</code> <code>date</code> <p>Day the comic was sent on Telegram.</p> required Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>class XKCDSentComicModel(Base):\n    \"\"\"Metadata about comics sent via Telegram.\n\n    Params:\n        sent_comic_id (INT_PK): Primary key for sent comic.\n        comic_num (int): Comic's number.\n        date_sent (date): Day the comic was sent on Telegram.\n    \"\"\"\n\n    __tablename__ = \"xkcd_sent_comic\"\n    __table_args__ = (sa.UniqueConstraint(\"comic_num\", name=\"_comic_num_uc\"),)\n\n    sent_comic_id: so.Mapped[INT_PK]\n    comic_num: so.Mapped[int] = so.mapped_column(sa.INTEGER)\n    date_sent: so.Mapped[date] = so.mapped_column(sa.Date)\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDSentComicRepositoryBase","title":"<code>XKCDSentComicRepositoryBase</code>","text":"<p>Base database repository for XKCDSentComic.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>class XKCDSentComicRepositoryBase(metaclass=abc.ABCMeta):\n    \"\"\"Base database repository for XKCDSentComic.\"\"\"\n\n    @abc.abstractmethod\n    def add(self, entity: XKCDSentComicModel):\n        \"\"\"Add new entity to repository.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def remove(self, entity: XKCDSentComicModel):\n        \"\"\"Remove existing entity from repository.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def get_by_id(self, comic_id: int) -&gt; XKCDSentComicModel:\n        \"\"\"Retrieve entity from repository by its ID.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDSentComicRepositoryBase.add","title":"<code>add(entity)</code>  <code>abstractmethod</code>","text":"<p>Add new entity to repository.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>@abc.abstractmethod\ndef add(self, entity: XKCDSentComicModel):\n    \"\"\"Add new entity to repository.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDSentComicRepositoryBase.get_by_id","title":"<code>get_by_id(comic_id)</code>  <code>abstractmethod</code>","text":"<p>Retrieve entity from repository by its ID.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>@abc.abstractmethod\ndef get_by_id(self, comic_id: int) -&gt; XKCDSentComicModel:\n    \"\"\"Retrieve entity from repository by its ID.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/models/#auto_xkcd.domain.xkcd.comic.models.XKCDSentComicRepositoryBase.remove","title":"<code>remove(entity)</code>  <code>abstractmethod</code>","text":"<p>Remove existing entity from repository.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/models.py</code> <pre><code>@abc.abstractmethod\ndef remove(self, entity: XKCDSentComicModel):\n    \"\"\"Remove existing entity from repository.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/","title":"repository","text":""},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDComicRepository","title":"<code>XKCDComicRepository</code>","text":"<p>             Bases: <code>XKCDComicRepositoryBase</code></p> <p>Database repository for handling XKCDComic entities.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>class XKCDComicRepository(XKCDComicRepositoryBase):\n    \"\"\"Database repository for handling XKCDComic entities.\"\"\"\n\n    def __init__(self, session: so.Session) -&gt; None:  # noqa: D107\n        assert session is not None, ValueError(\"session cannot be None\")\n        assert isinstance(session, so.Session), TypeError(\n            f\"session must be of type sqlalchemy.orm.Session. Got type: ({type(session)})\"\n        )\n\n        self.session: so.Session = session\n\n    def add(self, entity: XKCDComicModel) -&gt; None:\n        \"\"\"Add new entity to the database.\"\"\"\n        try:\n            self.session.add(instance=entity)\n            self.session.commit()\n        except IntegrityError as integ:\n            msg = Exception(\n                f\"Integrity error committing entity to database. Details: {integ}\"\n            )\n            log.warning(msg)\n\n            raise integ\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception committing entity to database. Details: {exc}\"\n            )\n\n            raise msg\n\n    def remove(self, entity: XKCDComicModel) -&gt; None:\n        \"\"\"Remove existing entity from the database.\"\"\"\n        try:\n            self.session.delete(instance=entity)\n            self.session.commit()\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception removing entity from database. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n\n    def get_all_comic_nums(self) -&gt; list[int]:\n        \"\"\"Return a list of all comic numbers in database entitites.\"\"\"\n        try:\n            all_comics: list[XKCDComicModel] = self.session.query(XKCDComicModel).all()\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting all comic numbers from database. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n\n        _nums: list[int] = []\n\n        for _comic in all_comics:\n            _nums.append(_comic.num)\n\n        return _nums\n\n    def get_all(self) -&gt; list[XKCDComicModel]:\n        \"\"\"Return a list of all entitites found in database.\"\"\"\n        try:\n            all_comics: list[XKCDComicModel] = self.session.query(XKCDComicModel).all()\n\n            return all_comics\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting all comic numbers from database. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n\n    def get_by_id(self, comic_id: int) -&gt; XKCDComicModel:\n        try:\n            return self.session.query(XKCDComicModel).get(comic_id)\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception retrieving entity by ID '{comic_id}'. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDComicRepository.add","title":"<code>add(entity)</code>","text":"<p>Add new entity to the database.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>def add(self, entity: XKCDComicModel) -&gt; None:\n    \"\"\"Add new entity to the database.\"\"\"\n    try:\n        self.session.add(instance=entity)\n        self.session.commit()\n    except IntegrityError as integ:\n        msg = Exception(\n            f\"Integrity error committing entity to database. Details: {integ}\"\n        )\n        log.warning(msg)\n\n        raise integ\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception committing entity to database. Details: {exc}\"\n        )\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDComicRepository.get_all","title":"<code>get_all()</code>","text":"<p>Return a list of all entitites found in database.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>def get_all(self) -&gt; list[XKCDComicModel]:\n    \"\"\"Return a list of all entitites found in database.\"\"\"\n    try:\n        all_comics: list[XKCDComicModel] = self.session.query(XKCDComicModel).all()\n\n        return all_comics\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception getting all comic numbers from database. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDComicRepository.get_all_comic_nums","title":"<code>get_all_comic_nums()</code>","text":"<p>Return a list of all comic numbers in database entitites.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>def get_all_comic_nums(self) -&gt; list[int]:\n    \"\"\"Return a list of all comic numbers in database entitites.\"\"\"\n    try:\n        all_comics: list[XKCDComicModel] = self.session.query(XKCDComicModel).all()\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception getting all comic numbers from database. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n\n    _nums: list[int] = []\n\n    for _comic in all_comics:\n        _nums.append(_comic.num)\n\n    return _nums\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDComicRepository.remove","title":"<code>remove(entity)</code>","text":"<p>Remove existing entity from the database.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>def remove(self, entity: XKCDComicModel) -&gt; None:\n    \"\"\"Remove existing entity from the database.\"\"\"\n    try:\n        self.session.delete(instance=entity)\n        self.session.commit()\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception removing entity from database. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDSentComicRepository","title":"<code>XKCDSentComicRepository</code>","text":"<p>             Bases: <code>XKCDSentComicRepositoryBase</code></p> <p>Database repository for handling XKCDSentComic models.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>class XKCDSentComicRepository(XKCDSentComicRepositoryBase):\n    \"\"\"Database repository for handling XKCDSentComic models.\"\"\"\n\n    def __init__(self, session: so.Session) -&gt; None:  # noqa: D107\n        assert session is not None, ValueError(\"session cannot be None\")\n        assert isinstance(session, so.Session), TypeError(\n            f\"session must be of type sqlalchemy.orm.Session. Got type: ({type(session)})\"\n        )\n\n        self.session: so.Session = session\n\n    def add(self, entity: XKCDSentComicModel) -&gt; None:\n        try:\n            self.session.add(instance=entity)\n            self.session.commit()\n        except IntegrityError as integ:\n            msg = Exception(\n                f\"Integrity error committing entity to database. Details: {integ}\"\n            )\n            log.warning(msg)\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception committing entity to database. Details: {exc}\"\n            )\n\n            raise msg\n\n    def remove(self, entity: XKCDSentComicModel) -&gt; None:\n        try:\n            self.session.delete(instance=entity)\n            self.session.commit()\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception removing entity from database. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n\n    def get_all_sent_comic_nums(self) -&gt; list[int]:\n        \"\"\"Return a list of all sent comic numbers in database entitites.\"\"\"\n        try:\n            all_sent_comics: list[XKCDSentComicModel] = self.session.query(\n                XKCDSentComicModel\n            ).all()\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting all sent comic numbers from database. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n\n        _nums: list[int] = []\n\n        for _comic in all_sent_comics:\n            _nums.append(_comic.num)\n\n        return _nums\n\n    def get_all(self) -&gt; list[XKCDSentComicModel]:\n        \"\"\"Return a list of all entitites found in database.\"\"\"\n        try:\n            all_comics: list[XKCDSentComicModel] = self.session.query(\n                XKCDSentComicModel\n            ).all()\n\n            return all_comics\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting all comic numbers from database. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n\n    def get_by_id(self, sent_comic_id: int) -&gt; XKCDSentComicModel:\n        \"\"\"Get an entity from the database by ID.\"\"\"\n        try:\n            return self.session.query(XKCDSentComicModel).get(sent_comic_id)\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception retrieving entity by ID '{sent_comic_id}'. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDSentComicRepository.get_all","title":"<code>get_all()</code>","text":"<p>Return a list of all entitites found in database.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>def get_all(self) -&gt; list[XKCDSentComicModel]:\n    \"\"\"Return a list of all entitites found in database.\"\"\"\n    try:\n        all_comics: list[XKCDSentComicModel] = self.session.query(\n            XKCDSentComicModel\n        ).all()\n\n        return all_comics\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception getting all comic numbers from database. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDSentComicRepository.get_all_sent_comic_nums","title":"<code>get_all_sent_comic_nums()</code>","text":"<p>Return a list of all sent comic numbers in database entitites.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>def get_all_sent_comic_nums(self) -&gt; list[int]:\n    \"\"\"Return a list of all sent comic numbers in database entitites.\"\"\"\n    try:\n        all_sent_comics: list[XKCDSentComicModel] = self.session.query(\n            XKCDSentComicModel\n        ).all()\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception getting all sent comic numbers from database. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n\n    _nums: list[int] = []\n\n    for _comic in all_sent_comics:\n        _nums.append(_comic.num)\n\n    return _nums\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/repository/#auto_xkcd.domain.xkcd.comic.repository.XKCDSentComicRepository.get_by_id","title":"<code>get_by_id(sent_comic_id)</code>","text":"<p>Get an entity from the database by ID.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/repository.py</code> <pre><code>def get_by_id(self, sent_comic_id: int) -&gt; XKCDSentComicModel:\n    \"\"\"Get an entity from the database by ID.\"\"\"\n    try:\n        return self.session.query(XKCDSentComicModel).get(sent_comic_id)\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception retrieving entity by ID '{sent_comic_id}'. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/","title":"schemas","text":""},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/#auto_xkcd.domain.xkcd.comic.schemas.ComicNumCSVData","title":"<code>ComicNumCSVData</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Store metadata about a comic number, like if the image has been saved.</p> <p>Parameters:</p> Name Type Description Default <code>comic_num</code> <code>int | str</code> <p>An XKCD comic number.</p> required <code>img_saved</code> <code>bool</code> <p>Whether or not <code>.png</code> of comic has been saved.</p> required Source code in <code>src/auto_xkcd/domain/xkcd/comic/schemas.py</code> <pre><code>class ComicNumCSVData(BaseModel):\n    \"\"\"Store metadata about a comic number, like if the image has been saved.\n\n    Params:\n        comic_num (int|str): An XKCD comic number.\n        img_saved (bool): Whether or not `.png` of comic has been saved.\n\n    \"\"\"\n\n    comic_num: t.Union[int, str] = Field(default=None)\n    img_saved: bool = Field(default=False)\n\n    @field_validator(\"comic_num\")\n    def validate_comic_num(cls, v) -&gt; int:\n        if isinstance(v, int):\n            return v\n\n        if isinstance(v, str):\n            try:\n                return int(v)\n            except Exception as exc:\n                raise Exception(f\"Unable to convert string to int: '{v}'.\")\n\n        raise ValidationError\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/#auto_xkcd.domain.xkcd.comic.schemas.CurrentComicMeta","title":"<code>CurrentComicMeta</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Structured data about the current XKCD comic.</p> <p>Parameters:</p> Name Type Description Default <code>comic_num</code> <code>int | str</code> <p>The XKCD comic's entry number.</p> required Source code in <code>src/auto_xkcd/domain/xkcd/comic/schemas.py</code> <pre><code>class CurrentComicMeta(BaseModel):\n    \"\"\"Structured data about the current XKCD comic.\n\n    Params:\n        comic_num (int|str): The XKCD comic's entry number.\n        last_updated (datetime.datetime, datetime.date, pendulum)\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    comic_num: t.Union[int, str] | None = Field(default=None)\n    last_updated: t.Union[datetime.datetime, pendulum.DateTime] | None = Field(\n        default=None\n    )\n\n    @field_validator(\"comic_num\")\n    def validate_comic_num(cls, v) -&gt; int:\n        if v is None:\n            return None\n\n        if isinstance(v, int):\n            return v\n\n        if isinstance(v, str):\n            try:\n                return int(v)\n            except Exception as exc:\n                raise Exception(f\"Unable to convert string to int: '{v}'.\")\n\n        raise ValidationError\n\n    @field_validator(\"last_updated\")\n    def validate_date_sent(cls, v) -&gt; pendulum.DateTime:\n        if v is None:\n            return None\n\n        if isinstance(v, pendulum.DateTime):\n            return v\n\n        else:\n            if isinstance(v, datetime.datetime):\n                d: pendulum.DateTime = pendulum.instance(obj=v)\n\n                return d\n\n            elif isinstance(v, str):\n                d = pendulum.parse(text=v)\n\n        raise ValidationError\n\n    def overwrite_last_updated(self) -&gt; t.Self:\n        \"\"\"Set/re-set class's .last_updated value.\"\"\"\n        ts: str | pendulum.DateTime = time_utils.get_ts()\n\n        self.last_updated = ts\n\n        return self\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/#auto_xkcd.domain.xkcd.comic.schemas.CurrentComicMeta.overwrite_last_updated","title":"<code>overwrite_last_updated()</code>","text":"<p>Set/re-set class's .last_updated value.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/schemas.py</code> <pre><code>def overwrite_last_updated(self) -&gt; t.Self:\n    \"\"\"Set/re-set class's .last_updated value.\"\"\"\n    ts: str | pendulum.DateTime = time_utils.get_ts()\n\n    self.last_updated = ts\n\n    return self\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/#auto_xkcd.domain.xkcd.comic.schemas.XKCDComic","title":"<code>XKCDComic</code>","text":"<p>             Bases: <code>XKCDComicBase</code></p> <p>XKCD comic data retrieved from the XKCD API.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>str</code> <p>Published year</p> required <code>month</code> <code>str</code> <p>Published month</p> required <code>day</code> <code>str</code> <p>Published day</p> required <code>num</code> <code>int</code> <p>XKCD comic number</p> required <code>title</code> <code>str</code> <p>XKCD comic title</p> required <code>transcript</code> <code>str</code> <p>XKCD comic transcript</p> required <code>alt_text</code> <code>str</code> <p>XKCD comic alt text</p> required <code>img_url</code> <code>str</code> <p>XKCD comic's image URL</p> required <code>img_bytes</code> <code>bytes</code> <p>XKCD comic image bytes. Initialized as <code>None</code> and populated once the image is requested.</p> required Source code in <code>src/auto_xkcd/domain/xkcd/comic/schemas.py</code> <pre><code>class XKCDComic(XKCDComicBase):\n    \"\"\"XKCD comic data retrieved from the XKCD API.\n\n    Params:\n        year (str): Published year\n        month (str): Published month\n        day (str): Published day\n        num (int): XKCD comic number\n        title (str): XKCD comic title\n        transcript (str): XKCD comic transcript\n        alt_text (str): XKCD comic alt text\n        img_url (str): XKCD comic's image URL\n        img_bytes (bytes): XKCD comic image bytes. Initialized as `None` and populated once the image is requested.\n\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/#auto_xkcd.domain.xkcd.comic.schemas.XKCDComicBase","title":"<code>XKCDComicBase</code>","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/schemas.py</code> <pre><code>class XKCDComicBase(BaseModel):\n    year: str = Field(default=None)\n    month: str = Field(default=None)\n    day: str = Field(default=None)\n    num: int = Field(default=None, alias=\"num\")\n    # link: str | None = Field(default=None)\n    title: str = Field(default=None)\n    transcript: str | None = Field(default=None)\n    alt_text: str = Field(default=None, alias=\"alt\")\n    img_url: str = Field(default=None, alias=\"img\")\n    img_bytes: bytes | None = Field(default=None, repr=False)\n\n    @property\n    def telegram_msg(self) -&gt; str:\n        \"\"\"Return a formatted message string for Telegram messages.\"\"\"\n        msg: str = f\"\"\"XKCD Comic for {self.month}-{self.day}-{self.year}\n\nTitle: {self.title}\nComic Number: {self.num}\nTranscript: {self.transcript}\nAlt: {self.alt_text}\nLink: {self.img_url}\n\"\"\"\n\n        return msg\n\n    @computed_field\n    @property\n    def link(self) -&gt; str:\n        _link: str = f\"{XKCD_URL_BASE}/{self.num}\"\n\n        return _link\n\n    @computed_field\n    @property\n    def comic_num_hash(self) -&gt; str:\n        try:\n            _hash: str = hash_utils.get_hash_from_str(input_str=str(self.num))\n\n            return _hash\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception getting hash from comic num ({type(self.num)}): {self.num}. Details: {exc}\"\n            )\n\n            raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/#auto_xkcd.domain.xkcd.comic.schemas.XKCDComicBase.telegram_msg","title":"<code>telegram_msg: str</code>  <code>property</code>","text":"<p>Return a formatted message string for Telegram messages.</p>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/#auto_xkcd.domain.xkcd.comic.schemas.XKCDComicOut","title":"<code>XKCDComicOut</code>","text":"<p>             Bases: <code>XKCDComicBase</code></p> <p>Append the XKCD comic's database ID.</p> Source code in <code>src/auto_xkcd/domain/xkcd/comic/schemas.py</code> <pre><code>class XKCDComicOut(XKCDComicBase):\n    \"\"\"Append the XKCD comic's database ID.\"\"\"\n\n    comic_id: int\n</code></pre>"},{"location":"reference/auto_xkcd/domain/xkcd/comic/schemas/#auto_xkcd.domain.xkcd.comic.schemas.XKCDSentComic","title":"<code>XKCDSentComic</code>","text":"<p>             Bases: <code>XKCDSentComicBase</code></p> <p>Metadata class for comics sent via Telegram.</p> <p>Parameters:</p> Name Type Description Default <code>comic_num</code> <code>int</code> <p>The XKCD comic's number</p> required <code>date_sent</code> <code>datetime | date | DateTime | Date</code> <p>Timestamp for when the comic was sent via Telegram.</p> required Source code in <code>src/auto_xkcd/domain/xkcd/comic/schemas.py</code> <pre><code>class XKCDSentComic(XKCDSentComicBase):\n    \"\"\"Metadata class for comics sent via Telegram.\n\n    Params:\n        comic_num (int): The XKCD comic's number\n        date_sent (datetime.datetime|datetime.date|pendulum.DateTime|pendulum.Date): Timestamp for when the comic was sent via Telegram.\n\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/__init__/","title":"helpers","text":"<p>\"Helper\" methods, classes, validators, &amp; context managers for the app.</p>"},{"location":"reference/auto_xkcd/helpers/data_ctl/__init__/","title":"data_ctl","text":"<p>Data control methods/context managers.</p> <p>Responsible for things like creating/updating a running list of comic numbers successfully requested.</p>"},{"location":"reference/auto_xkcd/helpers/data_ctl/methods/","title":"methods","text":""},{"location":"reference/auto_xkcd/helpers/data_ctl/methods/#auto_xkcd.helpers.data_ctl.methods.get_saved_imgs","title":"<code>get_saved_imgs(comic_img_dir=COMIC_IMG_DIR, as_int=True)</code>","text":"<p>Loop over comic images saved in <code>comic_img_dir</code> and extract comic number from filename.</p> <p>Parameters:</p> Name Type Description Default <code>comic_img_dir</code> <code>str | Path</code> <p>Path to a directory containing XKCD comic <code>.png</code>s.</p> <code>COMIC_IMG_DIR</code> <code>as_int</code> <code>bool</code> <p>Return list of integers if <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>If <code>as_int = False</code></p> <code>list[int]</code> <p>If <code>as_int = True</code></p> Source code in <code>src/auto_xkcd/helpers/data_ctl/methods.py</code> <pre><code>def get_saved_imgs(\n    comic_img_dir: t.Union[str, Path] = COMIC_IMG_DIR, as_int: bool = True\n) -&gt; list[str] | list[int]:\n    \"\"\"Loop over comic images saved in `comic_img_dir` and extract comic number from filename.\n\n    Params:\n        comic_img_dir (str|Path): Path to a directory containing XKCD comic `.png`s.\n        as_int (bool): Return list of integers if `True`.\n\n    Returns:\n        (list[str]): If `as_int = False`\n        (list[int]): If `as_int = True`\n\n    \"\"\"\n    assert comic_img_dir, ValueError(\"Missing comic_img_dir\")\n    assert isinstance(comic_img_dir, str) or isinstance(comic_img_dir, Path), TypeError(\n        f\"comic_img_dir must be a string or Path. Got type: ({type(comic_img_dir)})\"\n    )\n    if isinstance(comic_img_dir, str):\n        if \"~\" in comic_img_dir:\n            comic_img_dir: Path = Path(comic_img_dir).expanduser()\n        else:\n            comic_img_dir: Path = Path(comic_img_dir)\n    if isinstance(comic_img_dir, Path):\n        if \"~\" in f\"{comic_img_dir}\":\n            comic_img_dir: Path = comic_img_dir.expanduser()\n\n    if not comic_img_dir.exists():\n        log.warning(f\"Comic image directory '{comic_img_dir}' does not exist.\")\n        return\n\n    _imgs: list[Path] = path_utils.scan_dir(\n        target=comic_img_dir, as_pathlib=True, return_type=\"files\"\n    )\n    # log.debug(f\"_imgs ({type(_imgs)}): {_imgs}\")\n\n    if as_int:\n        int_list: list[int] = []\n\n        for img in _imgs:\n            img_stripped: str = img.stem\n            img_int = int(img_stripped)\n            int_list.append(img_int)\n\n        return sorted(int_list)\n\n    return _imgs\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/methods/#auto_xkcd.helpers.data_ctl.methods.read_current_comic_meta","title":"<code>read_current_comic_meta(current_comic_file=CURRENT_COMIC_FILE)</code>","text":"<p>Read the contents of the <code>current_comic.json</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>current_comic_file</code> <code>str | Path</code> <p>Path to the <code>current_comic.json</code> file.</p> <code>CURRENT_COMIC_FILE</code> Source code in <code>src/auto_xkcd/helpers/data_ctl/methods.py</code> <pre><code>def read_current_comic_meta(\n    current_comic_file: t.Union[str, Path] = CURRENT_COMIC_FILE\n) -&gt; CurrentComicMeta:\n    \"\"\"Read the contents of the `current_comic.json` file.\n\n    Params:\n        current_comic_file (str|Path): Path to the `current_comic.json` file.\n\n    \"\"\"\n    try:\n        current_comic_file = validate_current_comic_file(current_comic_file)\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception validating current_comic_file ({type(current_comic_file)}). Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    assert current_comic_file.exists(), FileNotFoundError(\n        f\"Could not find metadata file: {current_comic_file}\"\n    )\n\n    try:\n        with open(current_comic_file, \"r\") as f:\n            _data = json.load(f)\n            # log.debug(f\"Current comic metadata ({type(_data)}): {_data}\")\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception reading current comic metadata file: {current_comic_file}. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    try:\n        _metadata: CurrentComicMeta = CurrentComicMeta.model_validate(obj=_data)\n\n        return _metadata\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception converting comic metadata dict to CurrentComicMeta object. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/methods/#auto_xkcd.helpers.data_ctl.methods.update_comic_nums_file","title":"<code>update_comic_nums_file(file=Path(f'{DATA_DIR}/comic_nums.txt'), comic_num=None)</code>","text":"<p>Update/add to a <code>.txt</code> file tracking XKCD comics successfully requested.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to a <code>comic_nums.txt</code> file to update.</p> <code>Path(f'{DATA_DIR}/comic_nums.txt')</code> <code>comic_num</code> <code>int</code> <p>The comic number to add (if it does not exist).</p> <code>None</code> Source code in <code>src/auto_xkcd/helpers/data_ctl/methods.py</code> <pre><code>def update_comic_nums_file(\n    file: t.Union[str, Path] = Path(f\"{DATA_DIR}/comic_nums.txt\"), comic_num: int = None\n) -&gt; None:\n    \"\"\"Update/add to a `.txt` file tracking XKCD comics successfully requested.\n\n    Params:\n        file (str|Path): Path to a `comic_nums.txt` file to update.\n        comic_num (int): The comic number to add (if it does not exist).\n\n    \"\"\"\n    assert comic_num is not None, ValueError(\"Missing comic number\")\n    assert isinstance(comic_num, int), TypeError(f\"comic_num must be an integer\")\n\n    assert isinstance(file, str) or isinstance(file, Path), TypeError(\n        f\"file must be a string or Path object. Got type: ({type(file)})\"\n    )\n    if isinstance(file, str):\n        file = Path(file)\n    if \"~\" in str(file):\n        file = file.expanduser()\n\n    if not file.parent.exists():\n        try:\n            file.parent.mkdir(parents=True, exist_ok=True)\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception creating directory '{file.parent}'. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n            raise exc\n\n    if not file.exists():\n        file.touch()\n\n    with open(file=file, mode=\"r\") as f:\n        lines: list[str] = f.readlines()\n        comic_nums: list[int] = []\n        for line in lines:\n            stripped_line: str = line.strip()\n            if stripped_line:\n                comic_nums.append(int(stripped_line))\n\n    if comic_num not in comic_nums:\n        comic_nums.append(comic_num)\n\n    comic_nums.sort()\n    # log.debug(f\"Comic nums: {comic_nums}\")\n\n    with open(file, \"w\") as f:\n        for num in comic_nums:\n            f.write(f\"{num}\\n\")\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/methods/#auto_xkcd.helpers.data_ctl.methods.update_current_comic_meta","title":"<code>update_current_comic_meta(current_comic_file=CURRENT_COMIC_FILE, current_comic=None)</code>","text":"<p>Update the <code>current_comic.json</code> file with new data.</p> <p>Parameters:</p> Name Type Description Default <code>current_comic_file</code> <code>str | Path</code> <p>Path to the <code>current_comic.json</code> file.</p> <code>CURRENT_COMIC_FILE</code> <code>current_comic</code> <code>CurrentComicMeta</code> <p>A <code>CurrentComicMeta</code> object containing comic metadata, like comic number and a bool indicating whether the comic's image has been downloaded.</p> <code>None</code> Source code in <code>src/auto_xkcd/helpers/data_ctl/methods.py</code> <pre><code>def update_current_comic_meta(\n    current_comic_file: t.Union[str, Path] = CURRENT_COMIC_FILE,\n    current_comic: CurrentComicMeta = None,\n) -&gt; bool:\n    \"\"\"Update the `current_comic.json` file with new data.\n\n    Params:\n        current_comic_file (str|Path): Path to the `current_comic.json` file.\n        current_comic (CurrentComicMeta): A `CurrentComicMeta` object containing comic metadata, like comic number and a bool\n            indicating whether the comic's image has been downloaded.\n\n    \"\"\"\n    current_comic_file = validate_current_comic_file(\n        current_comic_file=current_comic_file\n    )\n    assert current_comic, ValueError(\"Missing CurrentComicMeta object\")\n\n    current_comic.overwrite_last_updated()\n\n    try:\n        _data = current_comic.model_dump()\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception dumping model. Details: {exc}\")\n\n    log.debug(f\"Saving current comic metadata: {_data}\")\n\n    try:\n        with open(current_comic_file, \"w\") as f:\n            # json.dump(_json, f)\n            json.dump(\n                obj=_data,\n                indent=4,\n                sort_keys=True,\n                cls=request_client.encoders.DateTimeEncoder,\n                default=str,\n                fp=f,\n            )\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception saving updated current comic metadata. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(msg)\n\n        raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/methods/#auto_xkcd.helpers.data_ctl.methods.validate_current_comic_file","title":"<code>validate_current_comic_file(current_comic_file=None)</code>","text":"<p>Validate the current_comic.json file. Create template file, if current_comic.json does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>current_comic_file</code> <code>str | Path</code> <p>Path to the <code>current_comic.json</code> file.</p> <code>None</code> Source code in <code>src/auto_xkcd/helpers/data_ctl/methods.py</code> <pre><code>def validate_current_comic_file(current_comic_file: t.Union[str, Path] = None) -&gt; Path:\n    \"\"\"Validate the current_comic.json file. Create template file, if current_comic.json does not exist.\n\n    Params:\n        current_comic_file (str|Path): Path to the `current_comic.json` file.\n\n    \"\"\"\n    assert current_comic_file, ValueError(\"Missing current comic details file\")\n    assert isinstance(current_comic_file, str) or isinstance(\n        current_comic_file, Path\n    ), TypeError(\n        f\"current_comic_file must be a str or Path. Got type: ({type(current_comic_file)})\"\n    )\n    if isinstance(current_comic_file, str):\n        current_comic_file: Path = Path(current_comic_file)\n    if \"~\" in f\"{current_comic_file}\":\n        current_comic_file = current_comic_file.expanduser()\n\n    if not current_comic_file.exists():\n        log.warning(\n            f\"Current comic file does not exist: '{current_comic_file}'. Creating empty file.\"\n        )\n\n        try:\n            data: dict[str, t.Union[str, None]] = {\n                \"comic_num\": None,\n                \"last_updated\": None,\n            }\n\n            ## Save to file\n            with open(file=current_comic_file, mode=\"w\") as f:\n                json.dump(obj=data, fp=f)\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception writing default dict to file '{current_comic_file}'. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n    return current_comic_file\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/context_managers/__init__/","title":"context_managers","text":"<p>Context managers (use as <code>with</code> statements) for the app.</p>"},{"location":"reference/auto_xkcd/helpers/data_ctl/context_managers/file/__init__/","title":"file","text":"<p>Context managers for handling file operations.</p>"},{"location":"reference/auto_xkcd/helpers/data_ctl/context_managers/file/handlers/","title":"handlers","text":""},{"location":"reference/auto_xkcd/helpers/data_ctl/context_managers/file/handlers/#auto_xkcd.helpers.data_ctl.context_managers.file.handlers.CurrentComicController","title":"<code>CurrentComicController</code>","text":"<p>             Bases: <code>AbstractContextManager</code></p> <p>Handler for the current_comic.json file.</p> <p>Parameters:</p> Name Type Description Default <code>current_comic_file</code> <code>str | Path</code> <p>Path to the <code>current_comic.json</code> file.</p> <code>CURRENT_COMIC_FILE</code> <code>mode</code> <code>str</code> <p>[Default: \"r\"] The file mode for opening the <code>current_comic.json</code> file.</p> <code>'r'</code> Source code in <code>src/auto_xkcd/helpers/data_ctl/context_managers/file/handlers.py</code> <pre><code>class CurrentComicController(AbstractContextManager):\n    \"\"\"Handler for the current_comic.json file.\n\n    Params:\n        current_comic_file (str|Path): Path to the `current_comic.json` file.\n        mode (str): [Default: \"r\"] The file mode for opening the `current_comic.json` file.\n\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        current_comic_file: t.Union[str, Path] = CURRENT_COMIC_FILE,\n        mode: str = \"r\",\n    ):\n        assert current_comic_file, ValueError(\"Missing current comic details file\")\n        assert isinstance(current_comic_file, str) or isinstance(\n            current_comic_file, Path\n        ), TypeError(\n            f\"current_comic_file must be a str or Path. Got type: ({type(current_comic_file)})\"\n        )\n        if isinstance(current_comic_file, str):\n            current_comic_file: Path = Path(current_comic_file)\n        if \"~\" in f\"{current_comic_file}\":\n            current_comic_file = current_comic_file.expanduser()\n\n        self.mode = mode.lower()\n        self.current_comic_file: Path = current_comic_file\n        self.current_comic_meta: dict = {\n            \"comic_num\": None,\n            \"last_updated\": None,\n        }\n\n    def __enter__(self):  # noqa: D105\n        self.file = open(self.current_comic_file, self.mode)\n\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):  # noqa: D105\n        if exc_type:\n            log.error(f\"({exc_type}): {exc_value}\")\n            log.trace(traceback)\n\n            return\n\n        if self.file:\n            self.file.close()\n\n    def read(self) -&gt; dict:\n        \"\"\"Read the file contents and load into a dict.\"\"\"\n        if self.mode != \"r\":\n            raise ValueError(\n                f\"File not opened in read mode. Opened with mode: {self.mode}\"\n            )\n\n        data: dict = json.load(self.file)\n\n        return data\n\n    def write(self, data) -&gt; None:\n        \"\"\"Write data dict to JSON file.\"\"\"\n        if self.mode != \"w\":\n            raise ValueError(\n                f\"File not opened in write mode. Opened with mode: {self.mode}\"\n            )\n\n        json.dump(data, self.file)\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/context_managers/file/handlers/#auto_xkcd.helpers.data_ctl.context_managers.file.handlers.CurrentComicController.read","title":"<code>read()</code>","text":"<p>Read the file contents and load into a dict.</p> Source code in <code>src/auto_xkcd/helpers/data_ctl/context_managers/file/handlers.py</code> <pre><code>def read(self) -&gt; dict:\n    \"\"\"Read the file contents and load into a dict.\"\"\"\n    if self.mode != \"r\":\n        raise ValueError(\n            f\"File not opened in read mode. Opened with mode: {self.mode}\"\n        )\n\n    data: dict = json.load(self.file)\n\n    return data\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/context_managers/file/handlers/#auto_xkcd.helpers.data_ctl.context_managers.file.handlers.CurrentComicController.write","title":"<code>write(data)</code>","text":"<p>Write data dict to JSON file.</p> Source code in <code>src/auto_xkcd/helpers/data_ctl/context_managers/file/handlers.py</code> <pre><code>def write(self, data) -&gt; None:\n    \"\"\"Write data dict to JSON file.\"\"\"\n    if self.mode != \"w\":\n        raise ValueError(\n            f\"File not opened in write mode. Opened with mode: {self.mode}\"\n        )\n\n    json.dump(data, self.file)\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/context_managers/file/handlers/#auto_xkcd.helpers.data_ctl.context_managers.file.handlers.SavedImgsController","title":"<code>SavedImgsController</code>","text":"<p>             Bases: <code>AbstractContextManager</code></p> <p>Context manager to load all filenames (i.e. comic numbers) from images in the <code>img_dir</code> directory.</p> <p>Parameters:</p> Name Type Description Default <code>img_dir</code> <code>str | Path</code> <p>Path to the directory containing comic images.</p> <code>COMIC_IMG_DIR</code> Source code in <code>src/auto_xkcd/helpers/data_ctl/context_managers/file/handlers.py</code> <pre><code>class SavedImgsController(AbstractContextManager):\n    \"\"\"Context manager to load all filenames (i.e. comic numbers) from images in the `img_dir` directory.\n\n    Params:\n        img_dir (str|Path): Path to the directory containing comic images.\n\n    \"\"\"\n\n    def __init__(self, img_dir: t.Union[str, Path] = COMIC_IMG_DIR):  # noqa: D107\n        assert img_dir, ValueError(\"Missing an img_dir\")\n        assert isinstance(img_dir, str) or isinstance(img_dir, Path), TypeError(\n            f\"img_dir must be of type str or Path. Got type: ({type(img_dir)})\"\n        )\n        if isinstance(img_dir, str):\n            img_dir: Path = Path(img_dir)\n        if \"~\" in f\"{img_dir}\":\n            img_dir: Path = Path(img_dir).expanduser()\n\n        assert img_dir.exists(), FileNotFoundError(f\"Could not find img_dir: {img_dir}\")\n\n        self.img_dir = img_dir\n        self.comic_nums: list[int] = None\n        self.comic_imgs: list[Path] = None\n\n    def __enter__(self):  # noqa: D105\n        _imgs: list[Path] = []\n        _img_nums: list[int] = []\n\n        try:\n            for p in path_utils.scan_dir(\n                self.img_dir, as_pathlib=True, return_type=\"files\"\n            ):\n                log.debug(f\"IGNORE_COMIC_NUMS ({type(IGNORE_COMIC_NUMS)})\")\n                log.debug(f\"Path stem ({type(p.stem)}): {p.stem}\")\n                if int(p.stem) in IGNORE_COMIC_NUMS:\n                    log.warning(f\"Ignoring comic #{p.stem}\")\n                    continue\n\n                _imgs.append(p)\n                _img_nums.append(int(p.stem))\n\n            self.comic_imgs = sorted(_imgs)\n            self.comic_nums = sorted(_img_nums)\n\n            return self\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception scanning path '{self.img_dir}' for saved comics. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n            raise exc\n\n    def __exit__(self, exc_type, exc_value, traceback):  # noqa: D105\n        if exc_type:\n            log.error(f\"({exc_type}): {exc_value}\")\n            log.trace(traceback)\n\n            return\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/data_ctl/context_managers/file/handlers/#auto_xkcd.helpers.data_ctl.context_managers.file.handlers.get_ts","title":"<code>get_ts(as_str=False, ts_format='YYYY-MM-DD_HH:mm:ss')</code>","text":"<p>Return a <code>pendulum.DateTime</code> or timestamp string.</p> <p>Parameters:</p> Name Type Description Default <code>as_str</code> <code>bool</code> <p>[Default: False] If <code>True</code>, return timestamp as a string.</p> <code>False</code> <code>ts_format</code> <code>str</code> <p>Format the timestamp.</p> <code>'YYYY-MM-DD_HH:mm:ss'</code> Source code in <code>src/auto_xkcd/helpers/data_ctl/context_managers/file/handlers.py</code> <pre><code>def get_ts(\n    as_str: bool = False, ts_format: str = \"YYYY-MM-DD_HH:mm:ss\"\n) -&gt; t.Union[str, pendulum.DateTime]:\n    \"\"\"Return a `pendulum.DateTime` or timestamp string.\n\n    Params:\n        as_str (bool): [Default: False] If `True`, return timestamp as a string.\n        ts_format (str): Format the timestamp.\n\n    \"\"\"\n    ts: pendulum.DateTime = pendulum.now()\n\n    if as_str:\n        ts: str = ts.format(ts_format)\n\n    return ts\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/validators/__init__/","title":"validators","text":"<p>Validator methods for the app.</p>"},{"location":"reference/auto_xkcd/helpers/validators/path_validators/__init__/","title":"path_validators","text":"<p>Validators for paths.</p>"},{"location":"reference/auto_xkcd/helpers/validators/path_validators/_validators/","title":"_validators","text":""},{"location":"reference/auto_xkcd/helpers/validators/path_validators/_validators/#auto_xkcd.helpers.validators.path_validators._validators.validate_path","title":"<code>validate_path(p=None, must_exist=False)</code>","text":"<p>Validate an input path.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>str | Path</code> <p>A path to a file or directory.</p> <code>None</code> <code>must_exist</code> <code>bool</code> <p>If <code>True</code>, raise <code>FileNotFoundError</code> if <code>p</code> does not exist.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>A validated <code>Path</code> object.</p> Source code in <code>src/auto_xkcd/helpers/validators/path_validators/_validators.py</code> <pre><code>def validate_path(p: t.Union[str, Path] = None, must_exist: bool = False) -&gt; Path:\n    \"\"\"Validate an input path.\n\n    Params:\n        p (str|Path): A path to a file or directory.\n        must_exist (bool): If `True`, raise `FileNotFoundError` if `p` does not exist.\n\n    Returns:\n        (Path): A validated `Path` object.\n\n    \"\"\"\n    assert p, ValueError(\"Path cannot be none\")\n    assert isinstance(p, str) or isinstance(p, Path), TypeError(\n        f\"Path must be a string or Path. Got type: ({type(p)})\"\n    )\n    if isinstance(p, str):\n        p: Path = Path(p)\n    if \"~\" in f\"{p}\":\n        p: Path = p.expanduser()\n\n    return p\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/validators/requests_validators/__init__/","title":"requests_validators","text":"<p>Validate <code>httpx</code> <code>Requests</code>, <code>Responses</code>, and <code>hishel</code> <code>CacheTransport</code>s.</p>"},{"location":"reference/auto_xkcd/helpers/validators/requests_validators/_validators/","title":"_validators","text":""},{"location":"reference/auto_xkcd/helpers/validators/requests_validators/_validators/#auto_xkcd.helpers.validators.requests_validators._validators.validate_hishel_cachetransport","title":"<code>validate_hishel_cachetransport(cache_transport=None)</code>","text":"<p>Return a validated <code>hishel.CacheTransport</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport instance.</p> <code>None</code> <p>Returns:</p> Type Description <code>CacheTransport</code> <p>A validated <code>hishel.CacheTransport</code> object.</p> Source code in <code>src/auto_xkcd/helpers/validators/requests_validators/_validators.py</code> <pre><code>def validate_hishel_cachetransport(\n    cache_transport: hishel.CacheTransport = None,\n) -&gt; hishel.CacheTransport:\n    \"\"\"Return a validated `hishel.CacheTransport` object.\n\n    Params:\n        cache_transport (hishel.CacheTransport): A cache transport instance.\n\n    Returns:\n        (hishel.CacheTransport): A validated `hishel.CacheTransport` object.\n\n    \"\"\"\n    assert cache_transport, ValueError(\"cache_transport cannot be None\")\n    assert isinstance(cache_transport, hishel.CacheTransport), TypeError(\n        f\"cache_transport must be a hishel.CacheTransport object. Got type: ({type(cache_transport)})\"\n    )\n\n    return cache_transport\n</code></pre>"},{"location":"reference/auto_xkcd/helpers/validators/xkcd_validators/__init__/","title":"xkcd_validators","text":"<p>Validators for XKCD comic objects.</p>"},{"location":"reference/auto_xkcd/helpers/validators/xkcd_validators/comic_validators/","title":"comic_validators","text":""},{"location":"reference/auto_xkcd/helpers/validators/xkcd_validators/comic_validators/#auto_xkcd.helpers.validators.xkcd_validators.comic_validators.validate_comic_nums_lst","title":"<code>validate_comic_nums_lst(comic_nums=None)</code>","text":"<p>Return a validated list of integers.</p> <p>Parameters:</p> Name Type Description Default <code>comic_nums</code> <code>list[int]</code> <p>A list of <code>int</code> values representing XKCD comic numbers.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>A validated list of integers.</p> Source code in <code>src/auto_xkcd/helpers/validators/xkcd_validators/comic_validators.py</code> <pre><code>def validate_comic_nums_lst(comic_nums: list[int] = None) -&gt; list[int]:\n    \"\"\"Return a validated list of integers.\n\n    Params:\n        comic_nums (list[int]): A list of `int` values representing XKCD comic numbers.\n\n    Returns:\n        (list[int]): A validated list of integers.\n\n    \"\"\"\n    assert comic_nums, ValueError(\"comic_nums must be a list of integers.\")\n    assert isinstance(comic_nums, list), TypeError(\n        f\"comic_nums must be a list. Got type: ({type(comic_nums)})\"\n    )\n    for i in comic_nums:\n        assert isinstance(i, int), TypeError(\n            f\"All comic numbers in comic_nums list must be integers. Found type: ({type(i)})\"\n        )\n\n    return comic_nums\n</code></pre>"},{"location":"reference/auto_xkcd/modules/__init__/","title":"modules","text":"<p>Modules are small bits of code (functions, classes, etc) that can be imported &amp; re-used in packages and/or pipelines.</p>"},{"location":"reference/auto_xkcd/modules/requests_prefab/__init__/","title":"requests_prefab","text":"<p>Pre-built <code>httpx.Request</code> objects, or methods to build a <code>Request</code>.</p>"},{"location":"reference/auto_xkcd/modules/requests_prefab/_reqs/","title":"_reqs","text":""},{"location":"reference/auto_xkcd/modules/requests_prefab/_reqs/#auto_xkcd.modules.requests_prefab._reqs.comic_num_req","title":"<code>comic_num_req(comic_num=None)</code>","text":"<p>Build an <code>httpx.Request</code> object from an input comic number.</p> <p>Parameters:</p> Name Type Description Default <code>comic_num</code> <code>(int, str)</code> <p>A comic number to request, i.e. 42.</p> <code>None</code> <p>Returns:</p> Type Description <code>request</code> <p>An initialized <code>httpx.Request</code> for the given <code>comic_num</code>.</p> Source code in <code>src/auto_xkcd/modules/requests_prefab/_reqs.py</code> <pre><code>def comic_num_req(comic_num: t.Union[int, str] = None) -&gt; httpx.Request:\n    \"\"\"Build an `httpx.Request` object from an input comic number.\n\n    Params:\n        comic_num (int, str): A comic number to request, i.e. 42.\n\n    Returns:\n        (httpx.request): An initialized `httpx.Request` for the given `comic_num`.\n\n    \"\"\"\n    assert comic_num, ValueError(\"Missing comic_num\")\n    assert isinstance(comic_num, int) or isinstance(comic_num, str), TypeError(\n        f\"comic_num must be an int or str. Got type: ({type(comic_num)})\"\n    )\n\n    ## Build URL from input comic_num\n    _url: str = f\"{XKCD_URL_BASE}/{comic_num}/{XKCD_URL_POSTFIX}\"\n\n    # log.debug(f\"Requesting URL for comic #{comic_num}: {_url}\")\n    try:\n        ## Build the request\n        req: httpx.Request = request_client.build_request(url=_url)\n\n        return req\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception building request for comic #{comic_num}. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/modules/requests_prefab/_reqs/#auto_xkcd.modules.requests_prefab._reqs.current_comic_req","title":"<code>current_comic_req()</code>","text":"<p>Build an <code>httpx.Request</code> object for the current XKCD comic.</p> <p>Returns:</p> Type Description <code>Request</code> <p>An initialized <code>httpx.Request</code> object for the current XKCD comic.</p> Source code in <code>src/auto_xkcd/modules/requests_prefab/_reqs.py</code> <pre><code>def current_comic_req() -&gt; httpx.Request:\n    \"\"\"Build an `httpx.Request` object for the current XKCD comic.\n\n    Returns:\n        (httpx.Request): An initialized `httpx.Request` object for the current XKCD comic.\n\n    \"\"\"\n    try:\n        req: httpx.Request = request_client.build_request(url=CURRENT_XKCD_URL)\n\n        return req\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception building current XKCD comic Request object. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise msg\n</code></pre>"},{"location":"reference/auto_xkcd/modules/xkcd_mod/__init__/","title":"xkcd_mod","text":"<p>Modules for XKCD comics, meant to be imported &amp; used in packages/pipelines.</p>"},{"location":"reference/auto_xkcd/modules/xkcd_mod/methods/","title":"methods","text":""},{"location":"reference/auto_xkcd/modules/xkcd_mod/methods/#auto_xkcd.modules.xkcd_mod.methods.list_missing_nums","title":"<code>list_missing_nums()</code>","text":"<p>Compile a list of missing XKCD comic numbers.</p> Source code in <code>src/auto_xkcd/modules/xkcd_mod/methods.py</code> <pre><code>def list_missing_nums() -&gt; list[int]:\n    \"\"\"Compile a list of missing XKCD comic numbers.\"\"\"\n    try:\n        current_comic_meta: CurrentComicMeta = data_ctl.read_current_comic_meta()\n        current_comic_num: int = current_comic_meta.comic_num\n        # log.debug(f\"Current comic number: {current_comic_num}\")\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception reading current comic metadata. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    all_comic_nums: list[int] = list(range(1, current_comic_num))\n\n    try:\n        saved_comic_nums: list[int] = data_ctl.get_saved_imgs()\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception loading saved comic numbers. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    missing_comic_nums: list[int] = [\n        num for num in all_comic_nums if num not in saved_comic_nums\n    ]\n    log.debug(f\"Found [{len(missing_comic_nums)}] missing comic number(s)\")\n\n    return missing_comic_nums\n</code></pre>"},{"location":"reference/auto_xkcd/modules/xkcd_mod/methods/#auto_xkcd.modules.xkcd_mod.methods.load_serialized_comic","title":"<code>load_serialized_comic(serialize_dir=SERIALIZE_COMIC_OBJECTS_DIR, comic_num=None)</code>","text":"<p>Load a serialized XKCDComic object from a file.</p> <p>Parameters:</p> Name Type Description Default <code>serialize_dir</code> <code>str | Path</code> <p>Path to directory containing serialized XKCDComic objects.</p> <code>SERIALIZE_COMIC_OBJECTS_DIR</code> <code>comic_num</code> <code>int</code> <p>Number of comic to load.</p> <code>None</code> Source code in <code>src/auto_xkcd/modules/xkcd_mod/methods.py</code> <pre><code>def load_serialized_comic(\n    serialize_dir: t.Union[str, Path] = SERIALIZE_COMIC_OBJECTS_DIR,\n    comic_num: int = None,\n) -&gt; XKCDComic | None:\n    \"\"\"Load a serialized XKCDComic object from a file.\n\n    Params:\n        serialize_dir (str|Path): Path to directory containing serialized XKCDComic objects.\n        comic_num (int): Number of comic to load.\n\n    \"\"\"\n    serialized_comic_filename: str = f\"{comic_num}.msgpack\"\n    serialized_comic_path: Path = Path(f\"{serialize_dir}/{serialized_comic_filename}\")\n\n    if not serialized_comic_path.exists():\n        log.warning(\n            f\"Could not find serialized comic at path '{serialized_comic_path}'.\"\n        )\n\n        return\n\n    log.debug(f\"Loading serialized comic from file '{serialized_comic_path}'.\")\n    try:\n        with open(serialized_comic_path, \"rb\") as f:\n            data = f.read()\n            deserialized: dict = msgpack.unpackb(data)\n            log.success(f\"Deserialized file contents into dict\")\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception deserializing comic data in file '{serialized_comic_path}'. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        return None\n\n    log.debug(f\"Converting serialized data dict to XKCDComic object\")\n    try:\n        comic: XKCDComic = XKCDComic.model_validate(deserialized)\n        log.success(\n            f\"Comic #{comic_num} serialized object restored to XKCDComic object.\"\n        )\n\n        return comic\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception validating serialized dict into XKCDComic object. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        return None\n</code></pre>"},{"location":"reference/auto_xkcd/modules/xkcd_mod/methods/#auto_xkcd.modules.xkcd_mod.methods.request_and_save_comic_img","title":"<code>request_and_save_comic_img(comic=None, cache_transport=None, output_dir=COMIC_IMG_DIR)</code>","text":"<p>Request a specific comic's image given an input <code>XKCDComic</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>comic</code> <code>XKCDComic</code> <p>An initialized <code>XKCDComic</code> object.</p> <code>None</code> <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport for the request client.</p> <code>None</code> <code>output_dir</code> <code>str | Path</code> <p>Path to the directory where comic image will be saved.</p> <code>COMIC_IMG_DIR</code> Source code in <code>src/auto_xkcd/modules/xkcd_mod/methods.py</code> <pre><code>def request_and_save_comic_img(\n    comic: XKCDComic = None,\n    cache_transport: hishel.CacheTransport = None,\n    output_dir: t.Union[str, Path] = COMIC_IMG_DIR,\n) -&gt; XKCDComic:\n    \"\"\"Request a specific comic's image given an input `XKCDComic` object.\n\n    Params:\n        comic (XKCDComic): An initialized `XKCDComic` object.\n        cache_transport (hishel.CacheTransport): A cache transport for the request client.\n        output_dir (str|Path): Path to the directory where comic image will be saved.\n\n    \"\"\"\n    ## Extract image URL\n    img_url: str = comic.img_url\n    ## Build request for image\n    img_req: httpx.Request = request_client.build_request(url=img_url)\n\n    img_bytes_filename: str = f\"{comic.num}.png\"\n    img_bytes_output_path: Path = Path(f\"{output_dir}/{img_bytes_filename}\")\n\n    try:\n        with request_client.HTTPXController(transport=cache_transport) as httpx_ctl:\n            try:\n                img_res: httpx.Response = httpx_ctl.send_request(request=img_req)\n                if not img_res.status_code == 200:\n                    log.warning(\n                        f\"Non-200 status code: [{img_res.status_code}: {img_res.reason_phrase}]: {img_res.text}\"\n                    )\n                else:\n                    log.success(f\"Comic image bytes requested\")\n\n            except Exception as exc:\n                msg = Exception(\n                    f\"Unhandled exception requesting img bytes. Details: {exc}\"\n                )\n                log.error(msg)\n                log.trace(exc)\n\n                raise exc\n\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception getting HTTPController. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    try:\n\n        img_bytes: bytes = img_res.content\n        if not img_bytes_output_path.exists():\n            request_client.save_bytes(\n                _bytes=img_bytes,\n                output_dir=output_dir,\n                output_filename=img_bytes_filename,\n            )\n        else:\n            log.warning(\n                f\"Image has already been saved to path '{img_bytes_output_path}'. Skipping\"\n            )\n\n        comic.img_bytes = img_bytes\n\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception saving img bytes. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    return comic\n</code></pre>"},{"location":"reference/auto_xkcd/modules/xkcd_mod/methods/#auto_xkcd.modules.xkcd_mod.methods.save_serialize_comic_object","title":"<code>save_serialize_comic_object(comic=None, output_dir=SERIALIZE_COMIC_OBJECTS_DIR, overwrite=False)</code>","text":"<p>Save an <code>XKCDComic</code> object to a <code>.msgpack</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>comic</code> <code>XKCDComic</code> <p>An instantiated <code>XKCDComic</code> object.</p> <code>None</code> <code>output_dir</code> <code>str | Path</code> <p>The directory where the serialized file will be saved. Note: the filename will be generated during function execution, you should not include the filename in this path.</p> <code>SERIALIZE_COMIC_OBJECTS_DIR</code> <code>overwrite</code> <code>bool</code> <p>If <code>True</code>, file will be overwritten if it already exists.</p> <code>False</code> Source code in <code>src/auto_xkcd/modules/xkcd_mod/methods.py</code> <pre><code>def save_serialize_comic_object(\n    comic: XKCDComic = None,\n    output_dir: t.Union[str, Path] = SERIALIZE_COMIC_OBJECTS_DIR,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Save an `XKCDComic` object to a `.msgpack` file.\n\n    Params:\n        comic (XKCDComic): An instantiated `XKCDComic` object.\n        output_dir (str|Path): The directory where the serialized file will be saved. Note: the filename will be generated\n            during function execution, you should not include the filename in this path.\n        overwrite (bool): If `True`, file will be overwritten if it already exists.\n\n    \"\"\"\n    serialized_filename = f\"{comic.num}.msgpack\"\n    output_filepath: Path = Path(f\"{output_dir}/{serialized_filename}\")\n\n    if output_filepath.exists():\n        log.warning(\n            f\"Comic #{comic.num} is serialized at path '{output_filepath}' already.\"\n        )\n        if overwrite:\n            log.info(f\"overwrite=True, continuing with serialization\")\n            pass\n\n        else:\n            log.warning(f\"overwrite=False, skipping.\")\n\n            return\n\n    try:\n        serialize_utils.serialize_dict(\n            data=comic.model_dump(),\n            output_dir=output_dir,\n            filename=serialized_filename,\n            overwrite=overwrite,\n        )\n        log.success(f\"XKCDComic object serialized to '{output_filepath}'.\")\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception serializing XKCDComic object. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/modules/xkcd_mod/response_handler/__init__/","title":"response_handler","text":""},{"location":"reference/auto_xkcd/modules/xkcd_mod/response_handler/methods/","title":"methods","text":""},{"location":"reference/auto_xkcd/modules/xkcd_mod/response_handler/methods/#auto_xkcd.modules.xkcd_mod.response_handler.methods.convert_comic_response_to_xkcdcomic","title":"<code>convert_comic_response_to_xkcdcomic(comic_res=None, serialize_response=True)</code>","text":"<p>Extract Response content to a dict, then validate into an XKCDComic object.</p> Source code in <code>src/auto_xkcd/modules/xkcd_mod/response_handler/methods.py</code> <pre><code>def convert_comic_response_to_xkcdcomic(\n    comic_res: httpx.Response = None, serialize_response: bool = True\n) -&gt; XKCDComic:\n    \"\"\"Extract Response content to a dict, then validate into an XKCDComic object.\"\"\"\n    ## Convert Response to dict\n    try:\n        comic_res_dict: dict = convert_response_to_dict(res=comic_res)\n        log.success(f\"Converted comic #{comic_res_dict['num']} Response to a dict.\")\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception converting comic Response to a dict\")\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    if serialize_response:\n        ## Save serialized Response\n        try:\n            serialize_comic_response_dict(res_dict=comic_res_dict)\n            log.success(f\"Saved serialized comic Response to file\")\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception serializing XKCD comic #{comic_res_dict['num']} response dict. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n            raise exc\n\n    ## Convert Response dict to XKCDComic\n    try:\n        comic: XKCDComic = convert_dict_to_xkcdcomic(_dict=comic_res_dict)\n        log.success(f\"Converted comic #{comic.num} Response dict to XKCDComic object\")\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception converting XKCD comic #{comic.num} response dict to XKCDComic object. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    return comic\n</code></pre>"},{"location":"reference/auto_xkcd/modules/xkcd_mod/response_handler/methods/#auto_xkcd.modules.xkcd_mod.response_handler.methods.convert_dict_to_xkcdcomic","title":"<code>convert_dict_to_xkcdcomic(_dict=None)</code>","text":"<p>Attempt to convert a dict into an XKCDComic object.</p> Source code in <code>src/auto_xkcd/modules/xkcd_mod/response_handler/methods.py</code> <pre><code>def convert_dict_to_xkcdcomic(_dict: dict = None) -&gt; XKCDComic:\n    \"\"\"Attempt to convert a dict into an XKCDComic object.\"\"\"\n    assert _dict, ValueError(\"Missing a dict input\")\n    assert isinstance(_dict, dict), TypeError(\n        f\"_dict input must be a dict object. Got type: ({type(_dict)})\"\n    )\n\n    try:\n        comic: XKCDComic = XKCDComic.model_validate(_dict)\n\n        return comic\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception converting current comic dict to XKCDComic object. Details: {exc}\"\n        )\n        log.error(msg)\n\n        raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/modules/xkcd_mod/response_handler/methods/#auto_xkcd.modules.xkcd_mod.response_handler.methods.convert_response_to_dict","title":"<code>convert_response_to_dict(res=None)</code>","text":"<p>Attempt to decode an <code>httpx.Response</code> into a dict.</p> Source code in <code>src/auto_xkcd/modules/xkcd_mod/response_handler/methods.py</code> <pre><code>def convert_response_to_dict(res: httpx.Response = None) -&gt; dict:\n    \"\"\"Attempt to decode an `httpx.Response` into a dict.\"\"\"\n    assert res, ValueError(\"Missing an httpx.Response object.\")\n    assert isinstance(res, httpx.Response), TypeError(\n        f\"res must be an httpx.Response object. Got type: ({type(res)})\"\n    )\n\n    with request_client.HTTPXController() as httpx_ctl:\n        try:\n            comic_dict: dict = httpx_ctl.decode_res_content(res=res)\n\n            return comic_dict\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception decoding comic response bytes. Details: {exc}\"\n            )\n            log.error(msg)\n\n            raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/packages/__init__/","title":"packages","text":"<p>Packages join modules together into pre-defined pieces of code.</p> <p>For example, the <code>xkcd_comic</code> package imports the <code>modules.xkcd_mod</code> package, then creates functions built around the code in that module.</p>"},{"location":"reference/auto_xkcd/packages/xkcd_comic/__init__/","title":"xkcd_comic","text":"<p>A package for interacting with the XKCD API.</p>"},{"location":"reference/auto_xkcd/packages/xkcd_comic/comic/__init__/","title":"comic","text":"<p>Request a specific comic, or multiple comics, or all missing comics.</p>"},{"location":"reference/auto_xkcd/packages/xkcd_comic/comic/methods/","title":"methods","text":""},{"location":"reference/auto_xkcd/packages/xkcd_comic/comic/methods/#auto_xkcd.packages.xkcd_comic.comic.methods.get_multiple_comics","title":"<code>get_multiple_comics(cache_transport=None, comic_nums=None, overwrite_serialized_comic=False, request_sleep=5)</code>","text":"<p>Request multiple comics, with a configurable delay between requests.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport for the request client.</p> <code>None</code> <code>comic_nums</code> <code>list[int]</code> <p>A list of XKCD comic numbers to request.</p> <code>None</code> <code>overwrite_serialized_comic</code> <code>bool</code> <p>If <code>True</code>, overwrite existing serialized file with data from request.</p> <code>False</code> <code>request_sleep</code> <code>int</code> <p>[Default: 5] Number of seconds to sleep between requests.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[XKCDComic]</code> <p>A list of <code>XKCDComic</code> objects.</p> Source code in <code>src/auto_xkcd/packages/xkcd_comic/comic/methods.py</code> <pre><code>def get_multiple_comics(\n    cache_transport: hishel.CacheTransport = None,\n    comic_nums: list[int] = None,\n    overwrite_serialized_comic: bool = False,\n    request_sleep: int = 5,\n) -&gt; list[XKCDComic]:\n    \"\"\"Request multiple comics, with a configurable delay between requests.\n\n    Params:\n        cache_transport (hishel.CacheTransport): A cache transport for the request client.\n        comic_nums (list[int]): A list of XKCD comic numbers to request.\n        overwrite_serialized_comic (bool): If `True`, overwrite existing serialized file with data from request.\n        request_sleep (int): [Default: 5] Number of seconds to sleep between requests.\n\n    Returns:\n        (list[XKCDComic]): A list of `XKCDComic` objects.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n\n    saved_comic_nums: list[int] = data_ctl.get_saved_imgs()\n    saved_comic_nums = validate_comic_nums_lst(comic_nums=saved_comic_nums)\n\n    comics: list[XKCDComic] = []\n\n    for comic_num in comic_nums:\n        if comic_num in IGNORE_COMIC_NUMS:\n            log.warning(f\"Comic #{comic_num} is in list of ignored comics. Skipping\")\n\n            continue\n\n        if comic_num in saved_comic_nums:\n            log.warning(f\"Comic #{comic_num} has already been downloaded. Skipping.\")\n            continue\n\n        try:\n            _comic: XKCDComic = get_single_comic(\n                cache_transport=cache_transport,\n                comic_num=comic_num,\n                overwrite_serialized_comic=overwrite_serialized_comic,\n            )\n            comics.append(_comic)\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception requesting comic #{comic_num}. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n            continue\n\n        log.info(f\"Waiting [{request_sleep}]s between requests ...\")\n        time.sleep(request_sleep)\n\n    if comics:\n        ## Suppress debug messaged on large comic list\n        if len(comics) &lt; 50:\n            log.debug(f\"Downloaded [{len(comics)}] comic(s)\")\n\n    return comics\n</code></pre>"},{"location":"reference/auto_xkcd/packages/xkcd_comic/comic/methods/#auto_xkcd.packages.xkcd_comic.comic.methods.get_single_comic","title":"<code>get_single_comic(cache_transport=None, comic_num=None, overwrite_serialized_comic=False)</code>","text":"<p>Request a single XKCD comic by its comic number.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport for the request client.</p> <code>None</code> <code>comic_num</code> <code>int</code> <p>The number of the XKCD comic strip to request.</p> <code>None</code> <p>Returns:</p> Type Description <code>XKCDComic</code> <p>The specified XKCD comic.</p> Source code in <code>src/auto_xkcd/packages/xkcd_comic/comic/methods.py</code> <pre><code>def get_single_comic(\n    cache_transport: hishel.CacheTransport = None,\n    comic_num: int = None,\n    overwrite_serialized_comic: bool = False,\n) -&gt; XKCDComic:\n    \"\"\"Request a single XKCD comic by its comic number.\n\n    Params:\n        cache_transport (hishel.CacheTransport): A cache transport for the request client.\n        comic_num (int): The number of the XKCD comic strip to request.\n\n    Returns:\n        (XKCDComic): The specified XKCD comic.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n\n    if comic_num in IGNORE_COMIC_NUMS:\n        log.warning(f\"Comic #{comic_num} is in list of ignored comic numbers. Skipping\")\n\n        return None\n\n    ## Get comic Response\n    try:\n        comic_res: httpx.Response = _request_comic_res(\n            cache_transport=cache_transport, comic_num=comic_num\n        )\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception getting comic #{comic_num}. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    ## Convert httpx.Response into XKCDComic object\n    try:\n        comic = xkcd_mod.response_handler.convert_comic_response_to_xkcdcomic(\n            comic_res=comic_res\n        )\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception converting httpx.Response to XKCDComic object. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    ## Save comic image\n    try:\n        comic: XKCDComic = xkcd_mod.request_and_save_comic_img(\n            comic=comic, cache_transport=cache_transport\n        )\n        log.success(f\"Comic #{comic.num} image saved.\")\n\n        SERIALIZE_COMIC: bool = True\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception saving comic image. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n        SERIALIZE_COMIC: bool = False\n\n    if SERIALIZE_COMIC:\n        log.info(f\"Serializing XKCDComic object for comic #{comic.num}\")\n\n        ## Serialize XKCDComic object\n        try:\n            xkcd_mod.save_serialize_comic_object(\n                comic=comic, overwrite=overwrite_serialized_comic\n            )\n            log.success(f\"Serialized XKCDComic object to file\")\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception saving XKCDComic to serialized file. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n    ## Update comic_nums.txt file\n    log.debug(f\"Updating comic_nums.txt file\")\n    try:\n        data_ctl.update_comic_nums_file(comic_num=comic.num)\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception updating comic_nums file. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    return comic\n</code></pre>"},{"location":"reference/auto_xkcd/packages/xkcd_comic/comic/scraper/","title":"scraper","text":"<p>Handle scraping the XKCD API for missing comics.</p>"},{"location":"reference/auto_xkcd/packages/xkcd_comic/comic/scraper/#auto_xkcd.packages.xkcd_comic.comic.scraper.scrape_missing_comics","title":"<code>scrape_missing_comics(cache_transport=None, request_sleep=5, max_list_size=50, loop_limit=None, overwrite_serialized_comic=False)</code>","text":"<p>Compile a list of missing comic numbers from saved comic images, then request those missing comics.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport for the request client.</p> <code>None</code> <code>request_sleep</code> <code>int</code> <p>[Default: 5] Number of seconds to sleep between requests.</p> <code>5</code> <code>max_list_size</code> <code>int</code> <p>[Default: 50] If list size exceeds <code>max_list_size</code>, break list into smaller \"chunks,\" then return a \"list of lists\", where each inner list is a \"chunk\" of 50 comic images.</p> <code>50</code> <code>loop_limit</code> <code>int | None</code> <p>[Default: None] Maximum number of times to loop, regardless of total number of missing comics.</p> <code>None</code> <code>overwrite_serialized_comic</code> <code>bool</code> <p>If <code>True</code>, overwrite existing serialized file with data from request.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[XKCDComic]</code> <p>A list of scraped XKCDComic objects.</p> Source code in <code>src/auto_xkcd/packages/xkcd_comic/comic/scraper.py</code> <pre><code>def scrape_missing_comics(\n    cache_transport: hishel.CacheTransport = None,\n    request_sleep: int = 5,\n    max_list_size: int = 50,\n    loop_limit: int | None = None,\n    overwrite_serialized_comic: bool = False,\n) -&gt; list[XKCDComic] | None:\n    \"\"\"Compile a list of missing comic numbers from saved comic images, then request those missing comics.\n\n    Params:\n        cache_transport (hishel.CacheTransport): A cache transport for the request client.\n        request_sleep (int): [Default: 5] Number of seconds to sleep between requests.\n        max_list_size (int): [Default: 50] If list size exceeds `max_list_size`, break list into smaller \"chunks,\"\n            then return a \"list of lists\", where each inner list is a \"chunk\" of 50 comic images.\n        loop_limit (int|None): [Default: None] Maximum number of times to loop, regardless of total number of missing comics.\n        overwrite_serialized_comic (bool): If `True`, overwrite existing serialized file with data from request.\n\n    Returns:\n        (list[XKCDComic]): A list of scraped XKCDComic objects.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n\n    ## Flip to True is list becomes chunked\n    LIST_CHUNKED: bool = False\n\n    log.info(f\"Finding missing comic numbers\")\n    missing_comic_nums: list[int] = xkcd_mod.list_missing_nums()\n\n    if not missing_comic_nums:\n        log.warning(f\"No missing comics found.\")\n\n        return\n\n    if len(missing_comic_nums) &gt; max_list_size:\n        log.warning(\n            f\"Number of missing comics ({len(missing_comic_nums)}) is greater than the configured max_list_size ({max_list_size}). Breaking into smaller chunks\"\n        )\n        missing_nums_lists: list[list[int]] = list_utils.make_list_chunks(\n            input_list=missing_comic_nums, max_list_size=max_list_size\n        )\n\n        LIST_CHUNKED = True\n\n    else:\n        log.debug(\n            f\"Number of missing comics [{len(missing_comic_nums)}] is below configured max_list_size ({max_list_size}). Continuing without breaking list into smaller chunks\"\n        )\n\n    log.debug(f\"List broken into smaller chunks: {LIST_CHUNKED}\")\n\n    if not LIST_CHUNKED:\n        ## List count is below max_list_size.\n\n        try:\n            missing_comics: list[XKCDComic] = get_multiple_comics(\n                cache_transport=cache_transport, comic_nums=missing_comic_nums\n            )\n\n            return missing_comics\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception scraping missing comics. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n            raise exc\n\n    else:\n        ## List size is greater than max_list_size. Break into smaller chunks &amp; loop\n\n        LIST_LOOP_COUNTER: int = 1\n        MAX_LOOPS: int = len(missing_nums_lists)\n        CONTINUE_LOOP: bool = True\n\n        COMIC_OBJ_LISTS: list[list[XKCDComic]] = []\n\n        log.info(f\"Looping over [{MAX_LOOPS}] list(s) of missing comics.\")\n\n        while CONTINUE_LOOP:\n\n            if LIST_LOOP_COUNTER &gt;= MAX_LOOPS:\n                log.debug(\n                    f\"Looped [{LIST_LOOP_COUNTER}/{MAX_LOOPS}] times. Exiting loop\"\n                )\n                CONTINUE_LOOP = False\n                break\n\n            for lst in missing_nums_lists:\n                log.debug(f\"Loop [{LIST_LOOP_COUNTER}/{MAX_LOOPS}]\")\n                log.debug(f\"List item(s): {len(lst)}\")\n\n                _comics: list[XKCDComic] = get_multiple_comics(\n                    cache_transport=cache_transport,\n                    comic_nums=lst,\n                    overwrite_serialized_comic=overwrite_serialized_comic,\n                    request_sleep=request_sleep,\n                )\n                COMIC_OBJ_LISTS.append(_comics)\n\n                LIST_LOOP_COUNTER += 1\n\n        log.debug(\n            f\"Joining [{len(COMIC_OBJ_LISTS)}] lists of XKCDComic objects into single list\"\n        )\n        try:\n            joined_list: list[XKCDComic] = list_utils.join_list_of_lists(\n                COMIC_OBJ_LISTS\n            )\n\n            return joined_list\n\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception joining chunked lists of XKCDComic objects into single list. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n            raise exc\n</code></pre>"},{"location":"reference/auto_xkcd/packages/xkcd_comic/current_comic/__init__/","title":"current_comic","text":"<p>The current XKCD comic module is separated from the <code>comic</code> module because there are so many extra operations involved with getting the current comic.</p>"},{"location":"reference/auto_xkcd/packages/xkcd_comic/current_comic/methods/","title":"methods","text":""},{"location":"reference/auto_xkcd/packages/xkcd_comic/current_comic/methods/#auto_xkcd.packages.xkcd_comic.current_comic.methods.get_current_comic","title":"<code>get_current_comic(cache_transport=None, overwrite_serialized_comic=False)</code>","text":"<p>Run through operations to get the current XKCD comic.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport for the request client.</p> <code>None</code> <code>overwrite_serialized_comic</code> <code>bool</code> <p>[Default: <code>False</code>] If <code>True</code>, overwrites serialized comic if it exists.</p> <code>False</code> <p>Returns:</p> Type Description <code>XKCDComic</code> <p>An instance of <code>XKCDComic</code>, with params filled by response data.</p> Source code in <code>src/auto_xkcd/packages/xkcd_comic/current_comic/methods.py</code> <pre><code>def get_current_comic(\n    cache_transport: hishel.CacheTransport = None,\n    overwrite_serialized_comic: bool = False,\n) -&gt; XKCDComic:\n    \"\"\"Run through operations to get the current XKCD comic.\n\n    Params:\n        cache_transport (hishel.CacheTransport): A cache transport for the request client.\n        overwrite_serialized_comic (bool): [Default: `False`] If `True`, overwrites serialized comic if it exists.\n\n    Returns:\n        (XKCDComic): An instance of `XKCDComic`, with params filled by response data.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n\n    ## Get comic Response\n    try:\n        current_comic_res: httpx.Response = _request_current_comic_res(\n            cache_transport=cache_transport\n        )\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception building current XKCD comic Request. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    ## Convert httpx.Response into XKCDComic object\n    try:\n        comic = xkcd_mod.response_handler.convert_comic_response_to_xkcdcomic(\n            comic_res=current_comic_res\n        )\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception converting httpx.Response to XKCDComic object. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    ## Save comic image\n    try:\n        comic: XKCDComic = xkcd_mod.request_and_save_comic_img(\n            comic=comic, cache_transport=cache_transport\n        )\n        log.success(f\"Comic #{comic.num} image saved.\")\n\n        SERIALIZE_COMIC: bool = True\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception saving comic image. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n        SERIALIZE_COMIC: bool = False\n\n    if SERIALIZE_COMIC:\n        log.info(f\"Serializing XKCDComic object for comic #{comic.num}\")\n\n        ## Serialize XKCDComic object\n        try:\n            xkcd_mod.save_serialize_comic_object(\n                comic=comic, overwrite=overwrite_serialized_comic\n            )\n            log.success(f\"Serialized XKCDComic object to file\")\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception saving XKCDComic to serialized file. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n    ## Update comic_nums.txt file\n    try:\n        data_ctl.update_comic_nums_file(comic_num=comic.num)\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception updating comic_nums file. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n    ## Update current_comic.json file\n    try:\n        _ts: str | DateTime = time_utils.get_ts()\n        current_comic_meta: CurrentComicMeta = CurrentComicMeta(\n            comic_num=comic.num, last_updated=_ts\n        )\n\n        try:\n            data_ctl.update_current_comic_meta(current_comic=current_comic_meta)\n            log.success(f\"Current comic metadata file updated.\")\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception updating current comic metadata file. Details: {exc}\"\n            )\n            log.error(msg)\n            log.trace(exc)\n\n            raise exc\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception updating current comic metadata. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    return comic\n</code></pre>"},{"location":"reference/auto_xkcd/pipelines/__init__/","title":"pipelines","text":"<p>Pipelines join packages &amp; modules into processing workflows, where a set of inputs control the operations the pipeline takes.</p> <p>Pipeline examples:</p> <ul> <li><code>pipeline_current_comic()</code>: A pipeline to request, process (serialize,     update <code>current_comic.json</code> file, etc), and return the current XKCD comic.</li> <li><code>pipeline_multiple_comics</code>: A pipeline to loop over a list of comic numbers &amp; download/save each one.</li> </ul>"},{"location":"reference/auto_xkcd/pipelines/comic_pipelines/__init__/","title":"comic_pipelines","text":"<p>Pipelines/workflows for XKCD comic operations.</p>"},{"location":"reference/auto_xkcd/pipelines/comic_pipelines/_pipelines/","title":"_pipelines","text":"<p>Comic pipelines for interacting with the XKCD API &amp; handling the response.</p>"},{"location":"reference/auto_xkcd/pipelines/comic_pipelines/_pipelines/#auto_xkcd.pipelines.comic_pipelines._pipelines.pipeline_current_comic","title":"<code>pipeline_current_comic(cache_transport=None, overwrite_serialized_comic=False)</code>","text":"<p>Pipeline to request &amp; process the current XKCD comic.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport for the request client.</p> <code>None</code> <code>overwrite_serialized_comic</code> <code>bool</code> <p>If <code>True</code>, overwrite existing serialized file with data from request.</p> <code>False</code> <p>Returns:</p> Type Description <code>XKCDComic</code> <p>The current XKCD comic.</p> Source code in <code>src/auto_xkcd/pipelines/comic_pipelines/_pipelines.py</code> <pre><code>def pipeline_current_comic(\n    cache_transport: hishel.CacheTransport = None,\n    overwrite_serialized_comic: bool = False,\n) -&gt; XKCDComic:\n    \"\"\"Pipeline to request &amp; process the current XKCD comic.\n\n    Params:\n        cache_transport (hishel.CacheTransport): A cache transport for the request client.\n        overwrite_serialized_comic (bool): If `True`, overwrite existing serialized file with data from request.\n\n    Returns:\n        (XKCDComic): The current XKCD comic.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n\n    log.info(\"&gt;&gt; Start current XKCD comic pipeline\")\n\n    try:\n        comic: XKCDComic = xkcd_comic.get_current_comic(\n            cache_transport=cache_transport,\n            overwrite_serialized_comic=overwrite_serialized_comic,\n        )\n        log.success(f\"Current XKCD comic requested\")\n\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception running current XKCD comic pipeline. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    log.info(\"&lt;&lt; End current XKCD comic pipeline\")\n\n    return comic\n</code></pre>"},{"location":"reference/auto_xkcd/pipelines/comic_pipelines/_pipelines/#auto_xkcd.pipelines.comic_pipelines._pipelines.pipeline_multiple_comics","title":"<code>pipeline_multiple_comics(cache_transport=None, comic_nums=None, overwrite_serialized_comic=False, request_sleep=5)</code>","text":"<p>Pipeline to request multiple comics at once.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport</code> <code>CacheTransport</code> <p>A cache transport for the request client.</p> <code>None</code> <code>comic_nums</code> <code>list[int]</code> <p>A list of comic numbers to download/process.</p> <code>None</code> <code>overwrite_serialized_comic</code> <code>bool</code> <p>If <code>True</code>, overwrite existing serialized file with data from request.</p> <code>False</code> <code>request_sleep</code> <code>int</code> <p>[Default: 5] Number of seconds to sleep between requests.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[XKCDComic]</code> <p>A list of the requested XKCD comics.</p> Source code in <code>src/auto_xkcd/pipelines/comic_pipelines/_pipelines.py</code> <pre><code>def pipeline_multiple_comics(\n    cache_transport: hishel.CacheTransport = None,\n    comic_nums: list[int] = None,\n    overwrite_serialized_comic: bool = False,\n    request_sleep: int = 5,\n) -&gt; list[XKCDComic]:\n    \"\"\"Pipeline to request multiple comics at once.\n\n    Params:\n        cache_transport (hishel.CacheTransport): A cache transport for the request client.\n        comic_nums (list[int]): A list of comic numbers to download/process.\n        overwrite_serialized_comic (bool): If `True`, overwrite existing serialized file with data from request.\n        request_sleep (int): [Default: 5] Number of seconds to sleep between requests.\n\n    Returns:\n        (list[XKCDComic]): A list of the requested XKCD comics.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n    comic_nums = validate_comic_nums_lst(comic_nums=comic_nums)\n\n    log.info(\"&gt;&gt; Start multiple comic pipeline\")\n\n    try:\n        comics: list[XKCDComic] = xkcd_comic.get_multiple_comics(\n            cache_transport=cache_transport,\n            comic_nums=comic_nums,\n            overwrite_serialized_comic=overwrite_serialized_comic,\n            request_sleep=request_sleep,\n        )\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception getting multiple comics. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    log.info(\"&lt;&lt; End multiple comic pipeline\")\n\n    return comics\n</code></pre>"},{"location":"reference/auto_xkcd/pipelines/comic_pipelines/_pipelines/#auto_xkcd.pipelines.comic_pipelines._pipelines.pipeline_scrape_missing_comics","title":"<code>pipeline_scrape_missing_comics(cache_transport=None, overwrite_serialized_comic=False, request_sleep=5, max_list_size=50, loop_limit=None)</code>","text":"<p>Pipeline to find &amp; download missing comic images.</p> Todo <p>Configurable scrape limits, like a maximum list size.</p> <p>Parameters:</p> Name Type Description Default <code>cache_transport(hishel.CacheTransport)</code> <p>A cache transport for the request client.</p> required <code>overwrite_serialized_comic</code> <code>bool</code> <p>If <code>True</code>, overwrite existing serialized file with data from request.</p> <code>False</code> <code>request_sleep</code> <code>int</code> <p>[Default: 5] Number of seconds to sleep between requests.</p> <code>5</code> <code>max_list_size</code> <code>int</code> <p>[Default: 50] If list size exceeds <code>max_list_size</code>, break list into smaller \"chunks,\" then return a \"list of lists\", where each inner list is a \"chunk\" of 50 comic images.</p> <code>50</code> <code>loop_limit</code> <code>int | None</code> <p>[Default: None] Maximum number of times to loop, regardless of total number of missing comics.</p> <code>None</code> Source code in <code>src/auto_xkcd/pipelines/comic_pipelines/_pipelines.py</code> <pre><code>def pipeline_scrape_missing_comics(\n    cache_transport: hishel.CacheTransport = None,\n    overwrite_serialized_comic: bool = False,\n    request_sleep: int = 5,\n    max_list_size: int = 50,\n    loop_limit: int | None = None,\n) -&gt; list[XKCDComic]:\n    \"\"\"Pipeline to find &amp; download missing comic images.\n\n    Todo:\n        Configurable scrape limits, like a maximum list size.\n\n    Params:\n        cache_transport(hishel.CacheTransport): A cache transport for the request client.\n        overwrite_serialized_comic (bool): If `True`, overwrite existing serialized file with data from request.\n        request_sleep (int): [Default: 5] Number of seconds to sleep between requests.\n        max_list_size (int): [Default: 50] If list size exceeds `max_list_size`, break list into smaller \"chunks,\"\n            then return a \"list of lists\", where each inner list is a \"chunk\" of 50 comic images.\n        loop_limit (int|None): [Default: None] Maximum number of times to loop, regardless of total number of missing comics.\n\n    \"\"\"\n    cache_transport = validate_hishel_cachetransport(cache_transport=cache_transport)\n\n    log.info(\"&gt;&gt; Start scrape missing comics pipeline\")\n\n    try:\n        scraped_comics: list[XKCDComic] = xkcd_comic.comic.scrape_missing_comics(\n            cache_transport=cache_transport,\n            request_sleep=request_sleep,\n            max_list_size=max_list_size,\n            loop_limit=loop_limit,\n            overwrite_serialized_comic=overwrite_serialized_comic,\n        )\n\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception scraping missing comics. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n        raise exc\n\n    log.info(\"&lt;&lt; End scrape missing comics pipeline\")\n\n    return scraped_comics\n</code></pre>"},{"location":"reference/auto_xkcd/utils/__init__/","title":"utils","text":"<p>Utility functions to help with things like list/Path operations, (de)serialization, etc.</p>"},{"location":"reference/auto_xkcd/utils/list_utils/__init__/","title":"list_utils","text":""},{"location":"reference/auto_xkcd/utils/list_utils/methods/","title":"methods","text":""},{"location":"reference/auto_xkcd/utils/list_utils/methods/#auto_xkcd.utils.list_utils.methods.join_list_of_lists","title":"<code>join_list_of_lists(list_of_lists=None)</code>","text":"<p>Join a list of other lists into a single list.</p> Source code in <code>src/auto_xkcd/utils/list_utils/methods.py</code> <pre><code>def join_list_of_lists(list_of_lists: list[list[t.Any]] = None) -&gt; list[t.Any]:\n    \"\"\"Join a list of other lists into a single list.\"\"\"\n    assert list_of_lists, ValueError(\"Missing list of lists to join\")\n    assert isinstance(list_of_lists, list), TypeError(\n        f\"list_of_lists must be a list of other lists. Got type: ({type(list_of_lists)})\"\n    )\n    for lst in list_of_lists:\n        assert isinstance(lst, list), TypeError(\n            f\"All lists within list_of_lists must be of type list. Got type: ({type(lst)})\"\n        )\n\n    ## Concatenate all lists into one using chain, then convert to set to remove duplicates\n    unique_elements = set(chain(*list_of_lists))\n\n    ## Convert set back to list\n    joined_list: list[t.Any] = list(sorted(unique_elements))\n    return joined_list\n</code></pre>"},{"location":"reference/auto_xkcd/utils/list_utils/methods/#auto_xkcd.utils.list_utils.methods.make_list_chunks","title":"<code>make_list_chunks(input_list=None, max_list_size=50)</code>","text":"<p>Break a list into smaller lists/\"chunks\" based on max_list_size.</p> <p>Parameters:</p> Name Type Description Default <code>input_list</code> <code>list</code> <p>The input list to be chunked.</p> <code>None</code> <code>max_list_size</code> <code>int</code> <p>The maximum size of each chunk.</p> <code>50</code> <p>Returns:</p> Type Description <code>list[list[Any]] | list[Any]</code> <p>list of lists: List of smaller lists or chunks.</p> Source code in <code>src/auto_xkcd/utils/list_utils/methods.py</code> <pre><code>def make_list_chunks(\n    input_list: list[t.Any] = None, max_list_size: int = 50\n) -&gt; list[list[t.Any]] | list[t.Any]:\n    \"\"\"Break a list into smaller lists/\"chunks\" based on max_list_size.\n\n    Params:\n        input_list (list): The input list to be chunked.\n        max_list_size (int): The maximum size of each chunk.\n\n    Returns:\n        list of lists: List of smaller lists or chunks.\n\n    \"\"\"\n    assert input_list, ValueError(\"Missing input list to break into smaller chunks\")\n    assert isinstance(input_list, list), TypeError(\n        f\"input_list must be a list. Got type: ({type(input_list)})\"\n    )\n\n    if max_list_size == 0 or max_list_size is None:\n        log.warning(\n            f\"No limit set on list size. Returning full list embedded in another list\"\n        )\n\n        return input_list\n\n    chunked_list: list[list] = []\n    ## Loop over objects in list, breaking into smaller list chunks each time\n    #  the iterator reaches max_list_size\n    for i in range(0, len(input_list), max_list_size):\n        chunked_list.append(input_list[i : i + max_list_size])\n\n    log.debug(\n        f\"Created [{len(chunked_list)}] list(s) of {max_list_size} or less items.\"\n    )\n\n    return chunked_list\n</code></pre>"},{"location":"reference/auto_xkcd/utils/serialize_utils/__init__/","title":"serialize_utils","text":""},{"location":"reference/auto_xkcd/utils/serialize_utils/methods/","title":"methods","text":""},{"location":"reference/auto_xkcd/utils/serialize_utils/methods/#auto_xkcd.utils.serialize_utils.methods.serialize_dict","title":"<code>serialize_dict(data=None, output_dir=None, filename=None, overwrite=False)</code>","text":"<p>Serialize a <code>dict</code> to a file using <code>msgpack</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Input data to serialize</p> <code>None</code> <code>output_dir</code> <code>str | Path</code> <p>Directory where <code>.msgpack</code> file will be saved.</p> <code>None</code> <code>filename</code> <code>str</code> <p>The name of the <code>.msgpack</code> file. If <code>.msgpack</code> is omitted, it will be appended during validation.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If <code>True</code>, serialization will occur even if the file already exists.</p> <code>False</code> Source code in <code>src/auto_xkcd/utils/serialize_utils/methods.py</code> <pre><code>def serialize_dict(\n    data: dict = None,\n    output_dir: t.Union[str, Path] = None,\n    filename: str = None,\n    overwrite: bool = False,\n) -&gt; bool:\n    \"\"\"Serialize a `dict` to a file using `msgpack`.\n\n    Params:\n        data (dict): Input data to serialize\n        output_dir (str|Path): Directory where `.msgpack` file will be saved.\n        filename (str): The name of the `.msgpack` file. If `.msgpack` is omitted, it will be appended during validation.\n        overwrite (bool): If `True`, serialization will occur even if the file already exists.\n\n    \"\"\"\n    assert data, ValueError(\"Missing data dict to serialize.\")\n    assert isinstance(data, dict), TypeError(\n        f\"data must be a dict. Got type: ({type(data)})\"\n    )\n\n    assert filename, ValueError(\"Missing an output filename\")\n    assert isinstance(filename, str), TypeError(\n        f\"filename should be a string. Got type: ({type(filename)})\"\n    )\n    if not filename.endswith(\".msgpack\"):\n        ## Append '.msgpack' if filename does not end with it already\n        filename: str = f\"{filename}.msgpack\"\n\n    if output_dir is None:\n        output_dir: Path = Path(f\"{SERIALIZE_DIR}/comic_responses\")\n    else:\n        assert isinstance(output_dir, str) or isinstance(output_dir, Path), TypeError(\n            f\"output_dir must be a string or Path object. Got type: ({type(output_dir)})\"\n        )\n        if isinstance(output_dir, str):\n            output_dir: Path = Path(output_dir)\n        if \"~\" in f\"{output_dir}\":\n            output_dir: Path = output_dir.expanduser()\n\n    if not output_dir.exists():\n        try:\n            output_dir.mkdir(parents=True, exist_ok=True)\n        except Exception as exc:\n            msg = Exception(\n                f\"Unhandled exception creating directory '{output_dir}'. Details: {exc}\"\n            )\n            log.trace(exc)\n\n            # raise exc\n\n            return False\n\n    ## Concatenate output_dir and filename into a Path object\n    output_path: Path = Path(f\"{output_dir}/{filename}\")\n\n    if not overwrite:\n        ## Skip if file exists and overwrite=False\n        if output_path.exists():\n            log.warning(f\"Serialized file already exists, skipping: {output_path}\")\n            return True\n\n    ## Create msgpack\n    try:\n        packed = msgpack.packb(data)\n\n    except Exception as exc:\n        msg = Exception(f\"Unhandled exception serializing input. Details: {exc}\")\n        log.error(msg)\n        log.trace(exc)\n\n        # raise exc\n        return False\n\n    try:\n        ## Save msgpack to file\n        with open(file=output_path, mode=\"wb\") as f:\n            f.write(packed)\n\n        return True\n    except Exception as exc:\n        msg = Exception(\n            f\"Unhandled exception saving serialized data to file '{output_path}'. Details: {exc}\"\n        )\n        log.error(msg)\n        log.trace(exc)\n\n        # raise exc\n\n        return False\n</code></pre>"}]}